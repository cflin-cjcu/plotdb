// Generated by LiveScript 1.3.1
var x$;
x$ = angular.module('plotDB');
x$.service('dataService', ['$rootScope', '$http', 'IOService', 'sampleData', 'baseService', 'plNotify', 'eventBus', 'plConfig'].concat(function($rootScope, $http, IOService, sampleData, baseService, plNotify, eventBus, plConfig){
  var name, service, Field, Dataset, dataService;
  name = 'dataset';
  service = {
    link: function(dataset){
      if (dataset._type.location === 'server') {
        return "/dataset/" + dataset.key + "/";
      }
      return "/dataset/?k=c" + dataset.key;
    },
    cache: {},
    cachedLoad: function(_type, key){
      var this$ = this;
      if (_type.location === 'local') {
        return this.load(_type, key);
      }
      if (this.cache[key]) {
        return Promise.resolve(this.cache[key]);
      }
      return this.load(_type, key).then(function(it){
        return this$.cache[key] = it;
      });
    },
    list: function(){
      return IOService.listRemotely({
        name: 'dataset',
        location: 'server'
      }).then(function(r){
        return r.map(function(it){
          return new Dataset(it);
        });
      });
    },
    init: function(){},
    localinfo: {
      rows: 0,
      size: 0,
      update: function(){
        var i$, ref$, len$, item, results$ = [];
        this.rows = 0;
        this.size = 0;
        for (i$ = 0, len$ = (ref$ = service.items).length; i$ < len$; ++i$) {
          item = ref$[i$];
          if (item._type.location === 'local') {
            this.rows += item.rows;
            results$.push(this.size += item.size);
          }
        }
        return results$;
      }
    }
  };
  Field = function(config){
    import$((this.dataset = null, this.location = 'server', this.name = null, this.datatype = null, this.data = [], this), config);
    return this;
  };
  Field.prototype = {
    update: function(){
      var this$ = this;
      if (this.location === 'sample') {
        return Promise.resolve(this);
      }
      return dataService.cachedLoad({
        location: this.location,
        name: 'dataset'
      }, this.dataset).then(function(dataset){
        var matched;
        matched = dataset.fields.filter(function(it){
          return it.name === this$.name;
        })[0];
        if (!matched) {
          return console.error("failed to update field data");
        }
        return import$(this$, matched);
      });
    }
    /*
    #toJson: -> angular.toJson(@{name, type} <<< {dataset: @dataset{type, key}})
    #TODO this might be called individually. should propagate to dataset?
    update: ->
      # failed only if remote dataset fetching failed
      (dataset) <~ @get-dataset!then
      if !dataset => return # standalone field won't need to update
      @data = dataset.[]data.map(~>it[@name])
      @settype!
    set-dataset: (dataset = null) -> # set null to clear dataset
      #if !dataset.type or !dataset.key => return Promise.reject(null)
      #(ret) <~ dataService.load dataset.type, dataset.key .then
      @_.dataset = dataset
      if dataset and dataset._type and dataset.key =>
        @dataset <<< dataset{_type, key} <<< {name: dataset.name}
      else @dataset._type <<< {_type: {}, key: null, name: null}
      Promise.resolve(dataset)
    get-dataset: -> # provide dataset or null for standalone field
      if @_.dataset => return Promise.resolve(that)
      if !@dataset._type or !@dataset.key => return Promise.resolve(null)
      (ret) <~ dataService.load @dataset._type, @dataset.key .then
      @_.dataset = ret
      @dataset <<< ret{_type, key} <<< {name: ret.name}
      @_.dataset
    settype: ->
      types = <[Boolean Percent Number Date String]> ++ [null]
      for type in types =>
        if !type => return @type = \String
        if !@data.map(-> plotdb[type]test it).filter(->!it).length =>
          @type = type
          break
    */
  };
  Dataset = function(config){
    import$(this, {
      name: "",
      description: "",
      type: "static",
      format: "csv",
      owner: null,
      createdtime: new Date(),
      modifiedtime: new Date(),
      permission: {
        'switch': 'publish',
        list: []
      },
      fields: [],
      _type: {
        location: 'server',
        name: 'dataset'
      }
    });
    import$(this, config);
    this.setFields(this.fields);
    return this;
  };
  Dataset.prototype = {
    setFields: function(fields){
      var res$, k, v, i$, ref$, len$, f1, j$, len1$, f2, this$ = this, results$ = [];
      fields == null && (fields = null);
      if (!fields || typeof fields !== 'object') {
        return;
      }
      if (!Array.isArray(fields)) {
        res$ = [];
        for (k in fields) {
          v = fields[k];
          res$.push({
            name: k,
            data: v
          });
        }
        fields = res$;
      }
      fields = fields.map(function(it){
        return new Field((it.dataset = this$.key, it.datasetname = this$.name, it.location = this$._type.location, it));
      });
      for (i$ = 0, len$ = (ref$ = this.fields).length; i$ < len$; ++i$) {
        f1 = ref$[i$];
        for (j$ = 0, len1$ = fields.length; j$ < len1$; ++j$) {
          f2 = fields[j$];
          if (f1.name !== f2.name) {
            continue;
          }
          f2.key = f1.key;
        }
      }
      this.fields = fields;
      this.rows = this.rows || ((ref$ = this.fields[0] || {}).data || (ref$.data = [])).length;
      this.size = 0;
      for (i$ = 0, len$ = (ref$ = this.fields).length; i$ < len$; ++i$) {
        f1 = ref$[i$];
        results$.push(this.size += (f1.data || "").length + ((f1.name || "").length + 1));
      }
      return results$;
    },
    update: function(){}
  };
  service.Field = Field;
  dataService = baseService.derive(name, service, Dataset);
  dataService.sample = sampleData.map(function(it){
    return new Dataset(it);
  });
  return dataService;
}));
x$.controller('dataFiles', ['$scope', 'dataService', 'plNotify', 'eventBus'].concat(function($scope, dataService, plNotify, eventBus){
  $scope.datasets = dataService.datasets;
  return dataService.list().then(function(ret){
    $scope.datasets = ret;
    $scope.edit = function(dataset){
      return eventBus.fire('dataset.edit', dataset);
    };
    $scope.chosen = {
      dataset: null,
      key: null
    };
    $scope.toggle = function(dataset){
      var ref$;
      if (!dataset || this.chosen.key === dataset.key) {
        return ref$ = this.chosen, ref$.dataset = null, ref$.key = null, ref$;
      }
      this.chosen.key = dataset.key;
      return this.chosen.dataset = dataset;
    };
    return $scope['delete'] = function(dataset){
      var this$ = this;
      return dataset['delete']().then(function(){
        return $scope.$apply(function(){
          return $scope.datasets = $scope.datasets.filter(function(it){
            return it.key !== dataset.key;
          });
        });
      });
    };
  });
}));
x$.controller('userDatasetList', ['$scope', '$http', 'dataService'].concat(function($scope, $http, dataService){
  var owner, that;
  owner = (that = /^\/user\/([^/]+)/.exec(window.location.pathname))
    ? that[1]
    : $scope.user.data ? $scope.user.data.key : null;
  $scope.q = {
    owner: owner
  };
  if ($scope.user.data && owner === $scope.user.data.key) {
    $scope.showPub = true;
  }
  return $http({
    url: '/d/dataset/me/count',
    method: 'GET'
  }).success(function(d){
    return $scope.datasetCount = d;
  }).error(function(d){
    return $scope.datasetCount = 0;
  });
}));
x$.controller('datasetList', ['$scope', 'IOService', 'dataService', 'Paging', 'plNotify', 'eventBus'].concat(function($scope, IOService, dataService, Paging, plNotify, eventBus){
  var that, dsfilter, box;
  $scope.paging = Paging;
  $scope.paging.limit = 50;
  $scope.datasets = [];
  $scope.mydatasets = [];
  $scope.samplesets = dataService.sample.map(function(it){
    return it.key = -Math.random(), it;
  });
  $scope.q = {};
  $scope.qLazy = {
    keyword: null
  };
  if ($scope.$parent.q) {
    import$($scope.q, $scope.$parent.q);
  }
  $scope.$watch('qLazy', function(){
    return $scope.loadList(1000, true);
  }, true);
  $scope.loadList = function(delay, reset){
    delay == null && (delay = 1000);
    reset == null && (reset = false);
    return Paging.load(function(){
      var payload, ref$;
      payload = import$(import$((ref$ = {}, ref$.offset = Paging.offset, ref$.limit = Paging.limit, ref$), $scope.q), $scope.qLazy);
      return IOService.listRemotely({
        name: 'dataset'
      }, payload);
    }, delay, reset).then(function(ret){
      var this$ = this;
      return $scope.$apply(function(){
        var data;
        data = (ret || []).map(function(it){
          return new dataService.dataset(it, true);
        });
        Paging.flexWidth(data);
        $scope.mydatasets = (reset
          ? []
          : $scope.mydatasets).concat(data);
        $scope.datasets = ($scope.useSample
          ? $scope.samplesets
          : []).concat($scope.mydatasets);
        if (!$scope.cur) {
          return $scope.setcur($scope.datasets[0]);
        }
      });
    });
  };
  $scope.chosen = {
    dataset: null,
    key: null
  };
  $scope.toggle = function(dataset){
    var ref$;
    if (!dataset || this.chosen.key === dataset.key) {
      return ref$ = this.chosen, ref$.dataset = null, ref$.key = null, ref$;
    }
    this.chosen.key = dataset.key;
    return this.chosen.dataset = dataset;
  };
  $scope['delete'] = function(dataset){
    var this$ = this;
    return dataset['delete']().then(function(){
      return $scope.$apply(function(){
        $scope.datasets = $scope.datasets.filter(function(it){
          return it.key !== dataset.key;
        });
        return plNotify.send('success', "dataset deleted.");
      });
    })['catch'](function(){
      return plNotify.send('danger', "failed to delete dataset.");
    });
  };
  $scope.inlineCreate = function(it){
    var this$ = this;
    return dataService.load(it._type, it.key).then(function(ret){
      var ds;
      ds = new dataService.dataset(ret);
      return $scope.datasets.splice(0, 0, ds);
    })['catch'](function(ret){
      console.error(ret);
      plNotify.send('error', "failed to load dataset. please try reloading");
      if (ret[1] === 'forbidden') {
        return window.location.href = '/403.html';
      }
    });
  };
  $scope.cur = null;
  $scope.setcur = function(it){
    return $scope.cur = it;
  };
  if (that = document.querySelectorAll(".ds-list")[0]) {
    $scope.limitscroll(that);
  }
  eventBus.listen('dataset.saved', function(dataset){
    var matched;
    dataset == null && (dataset = {});
    matched = $scope.datasets.filter(function(it){
      return it.key === dataset.key;
    })[0];
    if (matched) {
      return import$(matched, dataset);
    }
  });
  if ($('#list-end')) {
    Paging.loadOnScroll(function(){
      return $scope.loadList();
    }, $('#list-end'), $(".ds-list"));
  }
  $scope.loadList();
  dsfilter = document.querySelector('#dataset-filter .items');
  if (dsfilter) {
    box = dsfilter.getBoundingClientRect();
    dsfilter.style.height = (window.innerHeight - box.top - 50) + "px";
    $scope.jumpTo = function(dataset){
      return $scope.scrollto($("#dataset-" + dataset.key));
    };
  }
  $scope.transpose = function(dataset){
    return Promise.all(dataset.fields.map(function(it){
      return it.update();
    })).then(function(){
      return setTimeout(function(){
        var head, fields, i$, to$, i, j$, to1$, j, ref$, index;
        head = dataset.fields[0];
        fields = head.data.map(function(){
          return new dataService.Field({
            location: 'sample'
          });
        });
        for (i$ = 1, to$ = dataset.fields.length; i$ < to$; ++i$) {
          i = i$;
          for (j$ = 0, to1$ = head.data.length; j$ < to1$; ++j$) {
            j = j$;
            ((ref$ = fields[j]).data || (ref$.data = []))[i - 1] = dataset.fields[i].data[j];
            fields[j].name = head.data[j];
          }
        }
        index = new dataService.Field({
          location: 'sample'
        });
        index.data = dataset.fields.map(function(it){
          return it.name;
        });
        index.data.splice(0, 1);
        index.name = '欄位';
        fields = [index].concat(fields);
        return $scope.$apply(function(){
          return dataset.fields = fields;
        });
      }, 0);
    });
  };
  return $scope.columnize = function(dataset, start, end){
    start == null && (start = 1);
    end == null && (end = -1);
    return Promise.all(dataset.fields.map(function(it){
      return it.update();
    })).then(function(){
      return setTimeout(function(){
        var ref$, end, list, i, fields, pair, i$, to$, j$, j, k$, to1$, k;
        start >= 0 || (start = 0);
        start <= (ref$ = dataset.fields.length - 1) || (start = ref$);
        if (end < 0) {
          end = dataset.fields.length - 1;
        }
        end <= (ref$ = dataset.fields.length - 1) || (end = ref$);
        list = (function(){
          var i$, to$, results$ = [];
          for (i$ = 0, to$ = dataset.fields.length; i$ < to$; ++i$) {
            i = i$;
            results$.push(i);
          }
          return results$;
        }()).filter(function(it){
          return it < start || it > end;
        });
        fields = list.map(function(it){
          return new dataService.Field({
            location: 'sample',
            name: dataset.fields[it].name
          });
        });
        pair = ['Index', 'Value'].map(function(it){
          return new dataService.Field({
            location: 'sample',
            name: it
          });
        });
        for (i$ = 0, to$ = dataset.fields[0].data.length; i$ < to$; ++i$) {
          i = i$;
          for (j$ = start; j$ <= end; ++j$) {
            j = j$;
            for (k$ = 0, to1$ = fields.length; k$ < to1$; ++k$) {
              k = k$;
              fields[k].data.push(dataset.fields[list[k]].data[i]);
            }
            pair[0].data.push(dataset.fields[j].name);
            pair[1].data.push(dataset.fields[j].data[i]);
          }
        }
        fields = fields.concat(pair);
        return $scope.$apply(function(){
          return dataset.fields = fields;
        });
      }, 0);
    });
  };
}));
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}