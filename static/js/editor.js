// Generated by LiveScript 1.3.1
var x$;
x$ = angular.module('plotDB');
x$.controller('plEditor', ['$scope', '$http', '$timeout', '$interval', '$sce', 'plConfig', 'IOService', 'dataService', 'chartService', 'paletteService', 'themeService', 'plNotify'].concat(function($scope, $http, $timeout, $interval, $sce, plConfig, IOService, dataService, chartService, paletteService, themeService, plNotify){
  import$($scope, {
    plConfig: plConfig,
    theme: new themeService.theme(),
    chart: new chartService.chart(),
    showsrc: true,
    vis: 'preview',
    lastvis: null,
    plotdbDomain: plConfig.urlschema + "" + plConfig.domainIO,
    plotdbRenderer: $sce.trustAsResourceUrl(plConfig.urlschema + "" + plConfig.domainIO + "/render.html"),
    error: {
      msg: null,
      lineno: 0
    },
    codemirror: {
      code: {
        lineWrapping: true,
        lineNumbers: true,
        viewportMargin: Infinity,
        mode: 'javascript'
      },
      style: {
        lineWrapping: true,
        lineNumbers: true,
        viewportMargin: Infinity,
        mode: 'css'
      },
      doc: {
        lineWrapping: true,
        lineNumbers: true,
        viewportMargin: Infinity,
        mode: 'xml'
      },
      objs: []
    },
    canvas: {
      node: document.getElementById('chart-renderer'),
      window: document.getElementById('chart-renderer').contentWindow
    },
    type: null,
    service: null
  });
  import$($scope, {
    target: function(){
      return this[this.type];
    },
    mode: {
      set: function(value){
        return import$($scope, (function(){
          switch (value) {
          case 'chart':
            return {
              value: value,
              type: 'chart',
              service: chartService
            };
          case 'theme':
            return {
              value: value,
              type: 'theme',
              service: themeService
            };
          }
        }()));
      }
    },
    _save: function(nothumb){
      var key, ref$, refresh, k, this$ = this;
      nothumb == null && (nothumb = false);
      if (this.target().owner !== this.user.data.key) {
        key = this.target()._type.location === 'server' ? this.target().key : null;
        ref$ = this.target();
        ref$.key = null;
        ref$.owner = null;
        ref$.permission = {
          'switch': [],
          value: []
        };
        if (key) {
          this.target().parent = key;
        }
      }
      refresh = !this.target().key ? true : false;
      if (this.target().dimension) {
        this.target().dimlen = (function(){
          var results$ = [];
          for (k in this.target().dimension || {}) {
            results$.push(k);
          }
          return results$;
        }.call(this)).length;
      }
      return this.target().save().then(function(ret){
        return this$.$apply(function(){
          var link;
          if (nothumb) {
            plNotify.send('warning', this$.type + " saved, but thumbnail failed to update");
          } else {
            plNotify.send('success', this$.type + " saved");
          }
          link = this$.service.link(this$.target());
          if (refresh || !window.location.search) {
            window.location.href = link;
          }
          if (this$.save.handle) {
            $timeout.cancel(this$.save.handle);
          }
          this$.save.handle = null;
          return this$.backup.unguard(3000);
        });
      })['catch'](function(err){
        return this$.$apply(function(){
          plNotify.aux.error.io('save', this$.type, err);
          console.error("[save " + name + "]", err);
          if (this$.save.handle) {
            $timeout.cancel(this$.save.handle);
          }
          return this$.save.handle = null;
        });
      });
    },
    save: function(){
      var this$ = this;
      if (!$scope.user.authed()) {
        return $scope.auth.toggle(true);
      }
      if (this.save.handle) {
        return;
      }
      this.save.handle = $timeout(function(){
        this$.save.handle = null;
        return this$._save(true);
      }, 3000);
      return this.canvas.window.postMessage({
        type: 'snapshot'
      }, this.plotdbDomain);
    },
    clone: function(){
      var key, ref$;
      this.target().name = this.target().name + " - Copy";
      key = this.target()._type.location === 'server' ? this.target().key : null;
      ref$ = this.target();
      ref$.key = null;
      ref$.owner = null;
      ref$.parent = key;
      ref$.permission = {
        'switch': [],
        value: []
      };
      return this.save();
    },
    load: function(type, key){
      var this$ = this;
      return this.service.load(type, key).then(function(ret){
        this$[this$.type] = new this$.service[this$.type](import$(this$[this$.type], ret));
        this$.backup.check();
        $scope.backup.unguard(3000);
        return $scope.countline();
      })['catch'](function(ret){
        console.error(ret);
        plNotify.send('error', "failed to load chart. please try reloading");
        if (ret[1] === 'forbidden') {
          return window.location.href = '/403.html';
        }
      });
    },
    'delete': function(){
      var this$ = this;
      if (!this.target().key) {
        return;
      }
      this['delete'].handle = true;
      return this.target()['delete']().then(function(ret){
        plNotify.send('success', this$.type + " deleted");
        this$[this$.type] = new this$.service[this$.type]();
        $scope.backup.unguard(10000);
        setTimeout(function(){
          return window.location.href = "/" + this$.type + "/me/";
        }, 1000);
        return this$['delete'].handle = false;
      })['catch'](function(err){
        plNotify.send('error', "failed to delete " + this$.type);
        return this$['delete'].handle = false;
      });
    },
    resetConfig: function(){
      var k, ref$, v, results$ = [];
      if (this.chart) {
        for (k in ref$ = this.chart.config) {
          v = ref$[k];
          results$.push(v.value = v['default']);
        }
        return results$;
      }
    },
    dimension: {
      bind: function(event, dimension, field){
        var this$ = this;
        field == null && (field = {});
        return field.update().then(function(){
          if (dimension.multiple) {
            (dimension.fields || (dimension.fields = [])).push(field);
          } else {
            dimension.fields = [field];
          }
          return $scope.render();
        })['catch'](function(err){
          plNotify.send('error', "failed to bind field. try again later.");
          return console.error("chart.ls / dimension field binding failed due to : ", err);
        });
      },
      unbind: function(event, dimension, field){
        var idx;
        field == null && (field = {});
        idx = dimension.fields.indexOf(field);
        if (idx < 0) {
          return;
        }
        dimension.fields.splice(idx, 1);
        return $scope.render();
      }
    },
    reset: function(){
      return this.render();
    },
    render: function(rebind){
      var payload, ref$;
      rebind == null && (rebind = true);
      if (!this.chart) {
        return;
      }
      this.chart.updateData();
      payload = JSON.parse(angular.toJson({
        theme: this.theme,
        chart: this.chart
      }));
      ref$ = $scope.render;
      ref$.payload = payload;
      ref$.rebind = rebind;
      if (!rebind) {
        return this.canvas.window.postMessage({
          type: 'render',
          payload: payload,
          rebind: rebind
        }, this.plotdbDomain);
      } else {
        return this.canvas.window.postMessage({
          type: 'reload'
        }, this.plotdbDomain);
      }
    },
    renderAsync: function(rebind){
      var this$ = this;
      rebind == null && (rebind = true);
      if (!this.chart) {
        return;
      }
      if (this.renderAsync.handler) {
        $timeout.cancel(this.renderAsync.handler);
      }
      return this.renderAsync.handler = $timeout(function(){
        this$.renderAsync.handler = null;
        return this$.render(rebind);
      }, 500);
    },
    parse: {
      send: function(name){
        if (!$scope[name]) {
          return;
        }
        this[name].pending = true;
        return $scope.canvas.window.postMessage({
          type: "parse-" + name,
          payload: $scope[name].code.content
        }, $scope.plotdbDomain);
      },
      chart: function(){
        return this.send('chart');
      },
      theme: function(){
        return this.send('theme');
      }
    },
    countline: function(){
      var this$ = this;
      return ['code', 'style', 'doc'].map(function(it){
        this$.target()[it].lines = this$.target()[it].content.split('\n').length;
        return this$.target()[it].size = this$.target()[it].content.length;
      });
    },
    download: {
      prepare: function(){
        var this$ = this;
        return ['svg', 'png', 'plotdb'].map(function(n){
          return setTimeout(function(){
            return $scope.$apply(function(){
              return [this$[n].url = '', this$[n]()];
            });
          }, 300);
        });
      },
      svg: function(){
        return $scope.canvas.window.postMessage({
          type: 'getsvg'
        }, $scope.plotdbDomain);
      },
      png: function(){
        return $scope.canvas.window.postMessage({
          type: 'getpng'
        }, $scope.plotdbDomain);
      },
      plotdb: function(){
        var payload;
        payload = angular.toJson($scope.target());
        this.plotdb.url = URL.createObjectURL(new Blob([payload], {
          type: 'application/json'
        }));
        return this.plotdb.size = payload.length;
      }
    },
    colorblind: {
      val: 'normal',
      vals: ['normal', 'protanopia', 'protanomaly', 'deuteranopia', 'deuteranomaly', 'tritanopia', 'tritanomaly', 'achromatopsia', 'achromatomaly'],
      set: function(it){
        if (!in$(it, this.vals)) {
          return;
        }
        this.val = it;
        return $scope.canvas.window.postMessage({
          type: 'colorblind-emu',
          payload: it
        }, $scope.plotdbDomain);
      }
    },
    applyTheme: function(){
      var k, ref$, v, preset;
      if (this.chart && this.theme) {
        for (k in ref$ = this.chart.config) {
          v = ref$[k];
          if (v._bytheme) {
            delete this.chart.config[k];
          }
        }
        for (k in ref$ = this.chart.config) {
          v = ref$[k];
          if (!this.chart.config[k].hint) {
            continue;
          }
          preset = this.theme.typedef[this.chart.config[k].type[0].name];
          if (!preset) {
            continue;
          }
          if (preset[this.chart.config[k].hint] != null) {
            this.chart.config[k].value = preset[this.chart.config[k].hint];
          }
        }
        for (k in ref$ = this.theme.config) {
          v = ref$[k];
          if (!this.chart.config[k]) {
            this.chart.config[k] = import$({
              _bytheme: true
            }, v);
          } else if (this.chart.config[k].type[0].name !== v.type[0].name) {
            continue;
          } else {
            this.chart.config[k].value = v['default'];
          }
        }
      }
      if (this.theme) {
        return this.paledit.fromTheme(this.theme);
      }
    }
  });
  import$($scope, {
    backup: {
      enabled: false,
      guard: false,
      unguard: function(delay){
        var this$ = this;
        delay == null && (delay = 1000);
        this.guard = false;
        return $timeout(function(){
          var ref$;
          this$.guard = true;
          return ref$ = $scope.unsaved, delete $scope.unsaved, ref$;
        }, delay);
      },
      init: function(){
        var this$ = this;
        $scope.$watch($scope.type, function(){
          $scope.unsaved = true;
          if (!this$.enabled) {
            return;
          }
          if (this$.handle) {
            $timeout.cancel(this$.handle);
          }
          return this$.handle = $timeout(function(){
            this$.handle = null;
            return $scope.target().backup().then(function(){});
          }, 2000);
        }, true);
        this.unguard(3000);
        return window.onbeforeunload = function(){
          if (!this$.guard || !$scope.unsaved) {
            return null;
          }
          return "You have unsaved changes. Still wanna leave?";
        };
      },
      recover: function(){
        var this$ = this;
        if (!this.last || !this.last.object) {
          return;
        }
        $scope.target().recover(this.last.object);
        this.enabled = false;
        return $scope.target().cleanBackups().then(function(){
          return $scope.$apply(function(){
            return this$.check();
          });
        });
      },
      check: function(){
        var this$ = this;
        return $scope.target().backups().then(function(ret){
          return $scope.$apply(function(){
            this$.list = ret;
            this$.last = ret[0];
            return $timeout(function(){
              return this$.enabled = true;
            }, 4000);
          })['catch'](function(err){
            return console.error('fecth backup failed: #', err);
          });
        });
      }
    },
    charts: {
      list: chartService.sample.map(function(it){
        return new chartService.chart(it);
      }),
      set: function(it){
        var this$ = this;
        $scope.chart = it;
        if (!it) {
          return;
        }
        if (it._type.location === 'sample') {
          $scope.chart = new chartService.chart(it);
          $scope.chart.theme = $scope.theme;
          $scope.resetConfig();
          $scope.render();
          $scope.parse.theme();
          return;
        }
        return chartService.load(it._type, it.key).then(function(ret){
          $scope.chart = new chartService.chart(ret);
          $scope.chart.theme = $scope.theme;
          $scope.resetConfig();
          $scope.render();
          return $scope.parse.theme();
        })['catch'](function(ret){
          console.error(ret);
          return plNotify.send('error', "failed to load chart. please try reloading");
        });
      },
      init: function(){
        var this$ = this;
        return IOService.listRemotely({
          name: 'chart'
        }, {
          owner: $scope.user.data
            ? $scope.user.data.key
            : -1
        }).then(function(ret){
          return $scope.$apply(function(){
            return this$.list = (chartService.sample.concat(ret)).map(function(it){
              return new chartService.chart(it);
            });
          });
        })['catch'](function(){
          console.error(e);
          return plNotify.send('error', "failed to load chart list. use sample chart instead");
        });
      }
    },
    themes: {
      list: themeService.sample,
      set: function(it){
        return $scope.theme = it;
      },
      init: function(){
        var this$ = this;
        return themeService.list().then(function(ret){
          return $scope.$apply(function(){
            return this$.list = ret;
          });
        });
      }
    },
    editor: {
      'class': "",
      focus: function(){
        var this$ = this;
        return setTimeout(function(){
          return $scope.codemirror.objs.map(function(cm){
            var ret, k, v, this$ = this;
            ret = (function(){
              var ref$, results$ = [];
              for (k in ref$ = $scope.codemirror) {
                v = ref$[k];
                results$.push([k, v]);
              }
              return results$;
            }()).filter(function(it){
              return it[1].mode === cm.options.mode;
            })[0];
            if (!ret || !$scope.vis.startsWith(ret[0])) {
              return;
            }
            setTimeout(function(){
              return cm.focus();
            }, 10);
            if (ret[1].refreshed) {
              return;
            }
            cm.refresh();
            ret[1].refreshed = true;
            return setTimeout(function(){
              cm.refresh();
              if ($scope.error.lineno) {
                return $("#code-editor-code .CodeMirror-code > div:nth-of-type(" + $scope.error.lineno + ")").addClass('error');
              }
            }, 0);
          });
        }, 0);
      },
      update: function(){
        return this['class'] = [this.fullscreen.toggled ? 'fullscreen' : "", this.vis !== 'preview' ? 'active' : "", this.color.modes[this.color.idx]].join(" ");
      },
      fullscreen: {
        toggle: function(){
          this.toggled = !this.toggled;
          $scope.editor.update();
          return $scope.editor.focus();
        },
        toggled: false
      },
      color: {
        modes: ['normal', 'dark'],
        idx: 0,
        toggle: function(){
          this.idx = (this.idx + 1) % this.modes.length;
          return $scope.editor.update();
        }
      }
    },
    settingPanel: {
      toggle: function(){
        return this.toggled = !this.toggled;
      },
      toggled: false
    },
    sharePanel: {
      social: {
        facebook: null
      },
      isForkable: function(){
        var perms, ref$, forkable;
        perms = (ref$ = $scope.target().permission).value || (ref$.value = []);
        return forkable = !!perms.filter(function(it){
          return it.perm === 'fork' && it['switch'] === 'public';
        }).length;
      },
      init: function(){
        var this$ = this;
        return ['#edit-sharelink', '#edit-embedcode'].map(function(eventsrc){
          var clipboard;
          clipboard = new Clipboard(eventsrc);
          clipboard.on('success', function(){
            $(eventsrc).tooltip({
              title: 'copied',
              trigger: 'click'
            }).tooltip('show');
            return setTimeout(function(){
              return $(eventsrc).tooltip('hide');
            }, 1000);
          });
          clipboard.on('error', function(){
            $(eventsrc).tooltip({
              title: 'Press Ctrl+C to Copy',
              trigger: 'click'
            }).tooltip('show');
            return setTimeout(function(){
              return $(eventsrc).tooltip('hide');
            }, 1000);
          });
          $scope.$watch('sharePanel.link', function(it){
            var fbobj, k, v, pinobj, emailobj, linkedinobj, twitterobj;
            this$.embedcode = "<iframe src=\"" + it + "\"><iframe>";
            this$.thumblink = $scope.service.thumblink($scope.chart);
            fbobj = {
              app_id: '1546734828988373',
              display: 'popup',
              caption: $scope.target().name,
              picture: this$.thumblink,
              link: this$.link,
              name: $scope.target().name,
              redirect_uri: 'http://plotdb.com/',
              description: $scope.target().description || ""
            };
            this$.social.facebook = (["https://www.facebook.com/dialog/feed?"].concat((function(){
              var ref$, results$ = [];
              for (k in ref$ = fbobj) {
                v = ref$[k];
                results$.push(k + "=" + encodeURIComponent(v));
              }
              return results$;
            }()))).join('&');
            pinobj = {
              url: this$.link,
              media: this$.thumblink,
              description: $scope.target().description || ""
            };
            this$.social.pinterest = (["https://www.pinterest.com/pin/create/button/?"].concat((function(){
              var ref$, results$ = [];
              for (k in ref$ = pinobj) {
                v = ref$[k];
                results$.push(k + "=" + encodeURIComponent(v));
              }
              return results$;
            }()))).join('&');
            emailobj = {
              subject: "plotdb: " + $scope.target().name,
              body: $scope.target().description + " : " + this$.link
            };
            this$.social.email = (["mailto:?"].concat((function(){
              var ref$, results$ = [];
              for (k in ref$ = emailobj) {
                v = ref$[k];
                results$.push(k + "=" + encodeURIComponent(v));
              }
              return results$;
            }()))).join('&');
            linkedinobj = {
              mini: true,
              url: this$.link,
              title: $scope.target().name + " on PlotDB",
              summary: $scope.target().description,
              source: "plotdb.com"
            };
            this$.social.linkedin = (["http://www.linkedin.com/shareArticle?"].concat((function(){
              var ref$, results$ = [];
              for (k in ref$ = linkedinobj) {
                v = ref$[k];
                results$.push(k + "=" + encodeURIComponent(v));
              }
              return results$;
            }()))).join('&');
            twitterobj = {
              url: this$.link,
              text: $scope.target().name + " - " + ($scope.target().description || ''),
              hashtags: "dataviz,chart,visualization",
              via: "plotdb"
            };
            return this$.social.twitter = (["http://twitter.com/intent/tweet?"].concat((function(){
              var ref$, results$ = [];
              for (k in ref$ = twitterobj) {
                v = ref$[k];
                results$.push(k + "=" + encodeURIComponent(v));
              }
              return results$;
            }()))).join('&');
          });
          $scope.$watch('sharePanel.forkable', function(it){
            var forkable;
            forkable = this$.isForkable();
            if (forkable !== this$.forkable && this$.forkable != null) {
              $scope.target().permission.value = it
                ? [{
                  'switch': 'public',
                  perm: 'fork'
                }]
                : [];
              $scope.target().searchable = it;
              return this$.saveHint = true;
            }
          });
          return $scope.$watch($scope.type + ".permission.value", function(){
            var forkable;
            forkable = this$.isForkable();
            if (this$.forkable !== forkable && this$.forkable != null) {
              this$.saveHint = true;
            }
            return this$.forkable = forkable;
          }, true);
        });
      },
      saveHint: false,
      embedcode: "",
      link: "",
      toggle: function(){
        if (this.init) {
          this.init();
        }
        this.init = null;
        this.toggled = !this.toggled;
        return this.saveHint = false;
      },
      toggled: false,
      isPublic: function(){
        return in$("public", $scope.target().permission['switch']);
      },
      setPrivate: function(){
        var ref$;
        ((ref$ = $scope.target()).permission || (ref$.permission = {}))['switch'] = ['private'];
        return this.saveHint = true;
      },
      setPublic: function(){
        var ref$;
        ((ref$ = $scope.target()).permission || (ref$.permission = {}))['switch'] = ['public'];
        return this.saveHint = true;
      }
    },
    coloredit: {
      config: function(v, idx){
        return {
          'class': "no-palette text-input",
          context: "context" + idx,
          exclusive: true,
          palette: [v.value]
        };
      }
    },
    paledit: {
      convert: function(it){
        return it.map(function(it){
          return {
            id: it.key || Math.random() + "",
            text: it.name,
            data: it.colors
          };
        });
      },
      ldcp: null,
      item: null,
      fromTheme: function(theme){
        var themepal, k, v;
        if (!theme || !theme.config || !theme.config.palette) {
          return this.list = this.list.filter(function(it){
            return it.text !== 'Theme';
          });
        }
        themepal = this.list.filter(function(it){
          return it.text === 'Theme';
        })[0];
        if (!themepal) {
          themepal = {
            text: 'Theme',
            id: '456',
            children: null
          };
          this.list = [themepal].concat(this.list);
        }
        themepal.children = this.convert((function(){
          var ref$, results$ = [];
          for (k in ref$ = theme.config.palette) {
            v = ref$[k];
            results$.push((v.name = k, v));
          }
          return results$;
        }()));
        $('#pal-select option').remove();
        $('#pal-select optgroup').remove();
        return $('#pal-select').select2({
          allowedMethods: ['updateResults'],
          templateResult: function(state){
            var color, c;
            if (!state.data) {
              return state.text;
            }
            color = (function(){
              var i$, ref$, len$, results$ = [];
              for (i$ = 0, len$ = (ref$ = state.data).length; i$ < len$; ++i$) {
                c = ref$[i$];
                results$.push("<div class='color' " + ("style='background:" + c.hex + ";width:" + 100 / state.data.length + "%'") + "></div>");
              }
              return results$;
            }()).join("");
            return $(("<div class='palette select'><div class='name'>" + state.text + "</div>") + ("<div class='palette-color'>" + color + "</div></div>"));
          },
          data: this.list
        });
      },
      init: function(){
        var x$, iconPalSelectConfig, this$ = this;
        this.ldcp = new ldColorPicker(null, {}, $('#palette-editor .editor .ldColorPicker')[0]);
        this.ldcp.on('change-palette', function(){
          return setTimeout(function(){
            return $scope.$apply(function(){
              return this$.update();
            });
          }, 0);
        });
        this.list = [{
          text: 'Default',
          id: 'default',
          children: this.convert(paletteService.sample)
        }];
        x$ = $('#pal-select');
        x$.select2(iconPalSelectConfig = {
          allowedMethods: ['updateResults'],
          templateResult: function(state){
            var color, c;
            if (!state.data) {
              return state.text;
            }
            color = (function(){
              var i$, ref$, len$, results$ = [];
              for (i$ = 0, len$ = (ref$ = state.data).length; i$ < len$; ++i$) {
                c = ref$[i$];
                results$.push("<div class='color' " + ("style='background:" + c.hex + ";width:" + 100 / state.data.length + "%'") + "></div>");
              }
              return results$;
            }()).join("");
            return $(("<div class='palette select'><div class='name'>" + state.text + "</div>") + ("<div class='palette-color'>" + color + "</div></div>"));
          },
          data: this.list
        });
        x$.on('select2:closing', function(e){
          var i$, ref$, len$, item, ret;
          for (i$ = 0, len$ = (ref$ = this$.list).length; i$ < len$; ++i$) {
            item = ref$[i$];
            ret = item.children.filter(fn$)[0];
            if (ret) {
              break;
            }
          }
          if (!ret) {
            return;
          }
          $scope.$apply(function(){
            return this$.item.value = JSON.parse(JSON.stringify({
              colors: ret.data
            }));
          });
          return this$.ldcp.setPalette(this$.item.value);
          function fn$(it){
            return it.id === $(e.target).val();
          }
        });
        return x$;
      },
      update: function(){
        var ref$, src, des, pairing, i$, to$, i, d, j$, to1$, j, s, len$, pair, unpair;
        if (this.item) {
          ref$ = [this.item.value, this.ldcp.getPalette(), []], src = ref$[0], des = ref$[1], pairing = ref$[2];
          for (i$ = 0, to$ = des.colors.length; i$ < to$; ++i$) {
            i = i$;
            d = des.colors[i];
            for (j$ = 0, to1$ = src.colors.length; j$ < to1$; ++j$) {
              j = j$;
              s = src.colors[j];
              if (s.hex !== d.hex) {
                continue;
              }
              pairing.push([s, d, Math.abs(i - j)]);
            }
          }
          pairing.sort(function(a, b){
            return a[2] - b[2];
          });
          for (i$ = 0, len$ = pairing.length; i$ < len$; ++i$) {
            pair = pairing[i$];
            if (pair[0].pair || pair[1].pair) {
              continue;
            }
            pair[0].pair = pair[1];
            pair[1].pair = pair[0];
          }
          unpair = [
            src.colors.filter(function(it){
              return !it.pair;
            }), des.colors.filter(function(it){
              return !it.pair;
            })
          ];
          for (i$ = 0, to$ = Math.min(unpair[0].length, unpair[1].length); i$ < to$; ++i$) {
            i = i$;
            unpair[1][i].pair = unpair[0][i];
          }
          src.colors = des.colors.map(function(it){
            var ref$;
            if (it.pair) {
              return ref$ = it.pair, ref$.hex = it.hex, ref$;
            } else {
              return it;
            }
          });
          return src.colors.forEach(function(it){
            var ref$;
            return ref$ = it.pair, delete it.pair, ref$;
          });
        }
      },
      toggled: false,
      toggle: function(){
        this.toggled = !this.toggled;
        if (!this.toggled) {
          return this.update();
        }
      },
      edit: function(item){
        this.item = item;
        this.ldcp.setPalette(item.value);
        return this.toggled = true;
      }
    },
    switchPanel: function(){
      var this$ = this;
      return setTimeout(function(){
        return $scope.$apply(function(){
          var temp;
          temp = this$.vis;
          if (this$.vis === 'preview' && (!this$.lastvis || this$.lastvis === 'preview')) {
            this$.vis = 'code';
          } else if (this$.vis === 'preview') {
            this$.vis = this$.lastvis;
          } else {
            this$.vis = 'preview';
          }
          this$.lastvis = temp;
          if (this$.vis === 'preview') {
            return $scope.codemirror.objs.forEach(function(it){
              return it.getInputField().blur();
            });
          } else {
            return $scope.codemirror.objs.forEach(function(it){
              return it.refresh();
            });
          }
        });
      }, 0);
    },
    hidHandler: function(){
      var this$ = this;
      $scope.codemirrored = function(editor){
        return $scope.codemirror.objs.push(editor);
      };
      return document.body.addEventListener('keydown', function(e){
        if ((e.metaKey || e.altKey) && (e.keyCode === 13 || e.which === 13)) {
          return $scope.$apply(function(){
            return this$.switchPanel();
          });
        }
      });
    },
    checkParam: function(){
      var ret, key, ref$, location;
      if (!window.location.search) {
        return;
      }
      if (window.location.search === '?demo') {
        $scope.target().doc.content = $scope.service.sample[1].doc.content;
        $scope.target().style.content = $scope.service.sample[1].style.content;
        $scope.target().code.content = $scope.service.sample[1].code.content;
        return;
      }
      ret = /[?&]k=([sl])([^&#|?]+)/.exec(window.location.search);
      if (!ret) {
        return;
      }
      key = ret[2];
      ref$ = [ret[1] === 's' ? 'server' : 'local', ret[2]], location = ref$[0], key = ref$[1];
      return $scope.load({
        name: $scope.type,
        location: location
      }, key);
    },
    assets: {
      measure: function(){
        var ref$;
        return ((ref$ = $scope.target()).assets || (ref$.assets = [])).size = $scope.target().assets.map(function(it){
          return it.content.length;
        }).reduce(function(a, b){
          return a + b;
        }, 0);
      },
      preview: function(file){
        var datauri, iframe;
        this.preview.toggled = true;
        datauri = ["data:", file.type, ";charset=utf-8;base64,", file.content].join("");
        iframe = document.createElement("iframe");
        $('#assets-preview .iframe')[0].innerHTML = "<iframe></iframe>";
        return $('#assets-preview .iframe iframe')[0].src = datauri;
      },
      read: function(fobj){
        var this$ = this;
        return new Promise(function(res, rej){
          var name, that, type, file, fr;
          name = (that = /([^/]+\.?[^/.]*)$/.exec(fobj.name)) ? that[1] : 'unnamed';
          type = 'unknown';
          file = $scope.target().addFile(name, type, null);
          fr = new FileReader();
          fr.onload = function(){
            var result, idx, type, content, size, ref$;
            result = fr.result;
            idx = result.indexOf(';');
            type = result.substring(5, idx);
            content = result.substring(idx + 8);
            size = ((ref$ = $scope.target()).assets || (ref$.assets = [])).map(function(it){
              return (it.content || "").length;
            }).reduce(function(a, b){
              return a + b;
            }, 0) + content.length;
            if (size > 3000000) {
              $scope.$apply(function(){
                plNotify.alert("Assets size limit (3MB) exceeded. won't upload.");
                $scope.target().removeFile(file);
              });
            }
            file.type = type;
            file.content = content;
            $scope.$applyAsync(function(){
              return file.type = type, file.content = content, file;
            });
            return res(file);
          };
          return fr.readAsDataURL(fobj);
        });
      },
      handle: function(files){
        var i$, len$, file, results$ = [];
        for (i$ = 0, len$ = files.length; i$ < len$; ++i$) {
          file = files[i$];
          results$.push(this.read(file));
        }
        return results$;
      },
      node: null,
      init: function(){
        var x$, this$ = this;
        x$ = this.node = $('#code-editor-assets input');
        x$.on('change', function(){
          return this$.handle(this$.node[0].files);
        });
        return x$;
      }
    },
    monitor: function(){
      var this$ = this;
      this.assets.init();
      this.$watch('vis', function(vis){
        return $scope.editor.focus();
      });
      this.$watch($scope.type + ".assets", function(){
        return this$.assets.measure();
      }, true);
      this.$watch($scope.type + ".doc.content", function(){
        return this$.countline();
      });
      this.$watch($scope.type + ".style.content", function(){
        return this$.countline();
      });
      this.$watch($scope.type + ".code.content", function(){
        return this$.countline();
      });
      this.$watch($scope.type + ".doc.content", function(){
        return this$.renderAsync();
      });
      this.$watch($scope.type + ".style.content", function(){
        return this$.renderAsync();
      });
      this.$watch('theme', function(theme){
        this$.renderAsync();
        if (this$.chart) {
          return this$.chart.theme = theme ? theme.key : null;
        }
      });
      this.$watch('chart', function(chart){
        this$.renderAsync();
        if (this$.theme) {
          return this$.theme.chart = chart ? chart.key : null;
        }
      });
      this.$watch('chart.theme', function(key){
        if (this$.type === 'chart') {
          return this$.theme = this$.themes.list.filter(function(it){
            return it.key === key;
          })[0];
        }
      });
      this.$watch('theme.chart', function(key){
        if (this$.type === 'theme') {
          return this$.charts.set(this$.charts.list.filter(function(it){
            return it.key === key;
          })[0]);
        }
      });
      this.$watch("chart.code.content", function(code){
        if (this$.communicate.parseHandler) {
          $timeout.cancel(this$.communicate.parseHandler);
        }
        return this$.communicate.parseHandler = $timeout(function(){
          this$.communicate.parseHandler = null;
          return $scope.parse.chart();
        }, 500);
      });
      this.$watch('theme.code.content', function(code){
        if (!this$.theme) {
          return;
        }
        if (this$.communicate.parseThemeHandler) {
          $timeout.cancel(this$.communicate.parseThemeHandler);
        }
        return this$.communicate.parseThemeHandler = $timeout(function(){
          this$.communicate.parseThemeHandler = null;
          return $scope.parse.theme();
        }, 500);
      });
      this.$watch('chart.config', function(n, o){
        var ret, k, v;
        o == null && (o = {});
        ret = !!(function(){
          var ref$, results$ = [];
          for (k in ref$ = n) {
            v = ref$[k];
            results$.push([k, v]);
          }
          return results$;
        }()).filter(function(arg$){
          var k, v;
          k = arg$[0], v = arg$[1];
          return !o[k] || v.value !== o[k].value;
        }).map(function(it){
          return (it[1] || {}).rebindOnChange;
        }).filter(function(it){
          return it;
        }).length;
        return this$.renderAsync(ret);
      }, true);
      this.$watch(this.type + ".key", function(){
        return this$.sharePanel.link = chartService.sharelink(this$.target());
      });
      if ($('#data-fields')[0]) {
        $scope.limitscroll;
      }
      return $scope.limitscroll($('#chart-configs')[0]);
    },
    communicate: function(){
      var this$ = this;
      return window.addEventListener('message', function(arg$){
        var data;
        data = arg$.data;
        return $scope.$apply(function(){
          var ref$, config, dimension, k, v, typedef, ref1$, event, bytes, mime, buf, ints, i$, to$, idx;
          if (!data || typeof data !== 'object') {
            return;
          }
          if (data.type === 'error') {
            $('#code-editor-code .CodeMirror-code > .error').removeClass('error');
            $scope.error.msg = (data.payload || (data.payload = {})).msg || "";
            $scope.error.lineno = (data.payload || (data.payload = {})).lineno || 0;
            if ($scope.error.lineno) {
              return $("#code-editor-code .CodeMirror-code > div:nth-of-type(" + $scope.error.lineno + ")").addClass('error');
            }
          } else if (data.type === 'alt-enter') {
            return $scope.switchPanel();
          } else if (data.type === 'snapshot') {
            if (data.payload) {
              this$.target().thumbnail = data.payload;
            }
            return this$._save();
          } else if (data.type === 'parse-chart') {
            $scope.parse.chart.pending = false;
            ref$ = JSON.parse(data.payload), config = ref$.config, dimension = ref$.dimension;
            for (k in ref$ = this$.chart.dimension) {
              v = ref$[k];
              if (dimension[k] != null) {
                dimension[k].fields = v.fields;
              }
            }
            for (k in ref$ = this$.chart.config) {
              v = ref$[k];
              if (config[k] != null) {
                config[k].value = v.value;
              }
            }
            for (k in config) {
              v = config[k];
              if (!(v.value != null)) {
                v.value = v['default'];
              }
            }
            ref$ = this$.chart;
            ref$.config = config;
            ref$.dimension = dimension;
            return $scope.render();
          } else if (data.type === 'parse-theme') {
            $scope.parse.theme.pending = false;
            ref$ = JSON.parse(data.payload), config = ref$.config, typedef = ref$.typedef;
            ref$ = this$.theme;
            ref$.config = config;
            ref$.typedef = typedef;
            this$.applyTheme();
            return $scope.render();
          } else if (data.type === 'loaded') {
            if (!this$.chart) {
              return;
            }
            if ($scope.render.payload) {
              this$.canvas.window.postMessage((ref1$ = {
                type: 'render'
              }, ref1$.payload = (ref$ = $scope.render).payload, ref1$.rebind = ref$.rebind, ref1$), this$.plotdbDomain);
              $scope.render.payload = null;
            }
            if ($scope.parse.chart.pending) {
              if (this$.chart) {
                this$.canvas.window.postMessage({
                  type: 'parse-chart',
                  payload: this$.chart.code.content
                }, this$.plotdbDomain);
              }
              $scope.parse.chart.pending = null;
            }
            if ($scope.parse.theme.pending) {
              if (this$.theme) {
                this$.canvas.window.postMessage({
                  type: 'parse-theme',
                  payload: this$.theme.code.content
                }, this$.plotdbDomain);
              }
              return $scope.parse.theme.pending = null;
            }
          } else if (data.type === 'click') {
            if (document.dispatchEvent) {
              event = document.createEvent('MouseEvents');
              event.initEvent('click', true, true);
              event.synthetic = true;
              return document.dispatchEvent(event);
            } else {
              event = document.createEventObject();
              event.synthetic = true;
              return document.fireEvent("onclick", event);
            }
          } else if (data.type === 'getsvg') {
            if (!data.payload) {
              return $scope.download.svg.url = '#';
            }
            $scope.download.svg.url = URL.createObjectURL(new Blob([data.payload], {
              type: 'image/svg+xml'
            }));
            return $scope.download.svg.size = data.payload.length;
          } else if (data.type === 'getpng') {
            if (!data.payload) {
              return $scope.download.png.url = '#';
            }
            bytes = atob(data.payload.split(',')[1]);
            mime = data.payload.split(',')[0].split(':')[1].split(';')[0];
            if (mime !== 'image/png') {
              return $scope.download.png.url = '#';
            }
            buf = new ArrayBuffer(bytes.length);
            ints = new Uint8Array(buf);
            for (i$ = 0, to$ = bytes.length; i$ < to$; ++i$) {
              idx = i$;
              ints[idx] = bytes.charCodeAt(idx);
            }
            $scope.download.png.url = URL.createObjectURL(new Blob([buf], {
              type: 'image/png'
            }));
            return $scope.download.png.size = bytes.length;
          }
        });
      }, false);
    },
    fieldAgent: {
      init: function(){
        var this$ = this;
        return $('#field-agent').on('mousewheel', function(){
          return this$.setPosition();
        });
      },
      data: null,
      drag: {
        ging: false,
        start: function(){
          return this.ging = true;
        },
        end: function(){
          return this.ging = false;
        }
      },
      setPosition: function(){
        var box, box2, scroll;
        if (!this.node) {
          return;
        }
        box = this.node.getBoundingClientRect();
        box2 = this.node.parentNode.parentNode.getBoundingClientRect();
        scroll = {
          left: $('#data-fields').scrollLeft(),
          top: $('#data-fields').scrollTop()
        };
        return $('#field-agent').css({
          top: (box.top - box2.top + 55 - scroll.top) + "px",
          left: (box.left - box2.left - scroll.left) + "px",
          width: box.width + "px",
          height: box.height + "px"
        });
      },
      setProxy: function(e, data){
        var ref$, node, this$ = this;
        if (this.drag.ging) {
          return;
        }
        ref$ = [data, e.target], this.data = ref$[0], node = ref$[1];
        for (;;) {
          if (node.getAttribute("class").indexOf('data-field') >= 0) {
            break;
          }
          node = node.parentNode;
          if (node.nodeName.toLowerCase() === 'body') {
            return;
          }
        }
        return setTimeout(function(){
          this$.node = node;
          return this$.setPosition();
        }, 0);
      }
    },
    init: function(){
      this.communicate();
      this.hidHandler();
      this.monitor();
      this.checkParam();
      this.paledit.init();
      this.backup.init();
      this.fieldAgent.init();
      if (this.type === 'theme') {
        this.charts.init();
      }
      if (this.type === 'chart') {
        return this.themes.init();
      }
    }
  });
  $scope.mode.set(/^\/chart\//.exec(window.location.pathname) ? 'chart' : 'theme');
  return $scope.init();
}));
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}
function in$(x, xs){
  var i = -1, l = xs.length >>> 0;
  while (++i < l) if (x === xs[i]) return true;
  return false;
}