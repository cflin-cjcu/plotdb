// Generated by LiveScript 1.3.1
var x$;
x$ = angular.module('plotDB');
x$.service('IOService', ['$rootScope', '$http'].concat(function($rootScope, $http){
  var aux, ret;
  aux = {
    usedkey: {},
    localkey: function(){
      return (Math.random().toString(36) + "").substring(2);
    },
    saveLocally: function(item, res, rej){
      var list, i$, i, key;
      list = JSON.parse(localStorage.getItem("/db/list/" + item.type.name)) || [];
      if (!item.key) {
        for (i$ = 0; i$ <= 10; ++i$) {
          i = i$;
          key = this.localkey();
          if (i === 10 || (!in$(key, list) && !this.usedkey[key])) {
            break;
          }
        }
        if (i === 10) {
          return rej([true, "generate local key failed"]);
        }
        item.key = key;
        this.usedkey[key] = true;
      }
      if (item.key && !in$(item.key, list)) {
        list.push(item.key);
      }
      item[!item.createdTime ? "createdTime" : "modifiedTime"] = new Date().getTime();
      localStorage.setItem("/db/list/" + item.type.name, angular.toJson(list));
      localStorage.setItem("/db/" + item.type.name + "/" + item.key, angular.toJson(item));
      return res(item);
    },
    saveRemotely: function(item, res, rej){
      var config;
      item[!item.createdTime ? "createdTime" : "modifiedTime"] = new Date().getTime();
      config = import$({
        data: item
      }, item.key
        ? {
          url: "/d/" + item.type.name + "/" + item.key,
          method: 'PUT'
        }
        : {
          url: "/d/" + item.type.name,
          method: 'POST'
        });
      return $http(config).success(function(ret){
        return res(ret);
      }).error(function(d, status){
        return rej([true, d, status]);
      });
    },
    loadLocally: function(type, key, res, rej){
      var ret;
      ret = JSON.parse(localStorage.getItem("/db/" + type.name + "/" + key));
      if (ret) {
        return res(ret);
      } else {
        return rej([true, "no such item"]);
      }
    },
    loadRemotely: function(type, key, res, rej){
      var config;
      config = {
        url: "/d/" + type.name + "/" + key,
        method: 'GET'
      };
      return $http(config).success(function(ret){
        return res(ret);
      }).error(function(d){
        return rej([true, d.toString()]);
      });
    },
    deleteLocally: function(type, key, res, rej){
      var list;
      list = JSON.parse(localStorage.getItem("/db/list/" + type.name)) || [];
      if (!in$(key, list)) {
        return rej([true, "no such item"]);
      }
      list = list.filter(function(it){
        return it !== key;
      });
      localStorage.setItem("/db/list/" + type.name, angular.toJson(list));
      localStorage.setItem("/db/" + type.name + "/" + key, null);
      return res();
    },
    deleteRemotely: function(type, key, res, rej){
      var config;
      config = {
        url: "/d/" + type.name + "/" + key,
        method: 'DELETE'
      };
      return $http(config).success(function(ret){
        return res(ret);
      }).error(function(d){
        d == null && (d = "");
        return rej([true, d.toString()]);
      });
    },
    listLocally: function(type, res, rej){
      var list, ret, i$, len$, item, obj;
      list = JSON.parse(localStorage.getItem("/db/list/" + type.name)) || [];
      ret = [];
      for (i$ = 0, len$ = list.length; i$ < len$; ++i$) {
        item = list[i$];
        obj = JSON.parse(localStorage.getItem("/db/" + type.name + "/" + item));
        if (obj && obj.key) {
          ret.push(obj);
        }
      }
      return res(ret);
    },
    listRemotely: function(type, res, rej, query){
      query == null && (query = null);
      return $http({
        url: "/d/" + type.name + (query ? '?' + query : ''),
        method: 'GET'
      }).success(function(ret){
        return res(ret);
      }).error(function(d){
        return rej([true, d.toString()]);
      });
    },
    verifyType: function(item){
      if (!item || !item.type || typeof item.type !== 'object') {
        return true;
      }
      if (!item.type.name || !item.type.location) {
        return true;
      }
      return false;
    }
  };
  return ret = {
    aux: aux,
    save: function(item){
      var this$ = this;
      return new Promise(function(res, rej){
        if (aux.verifyType(item)) {
          return rej([true, "type incorrect"]);
        }
        if (item.type.location === 'local') {
          return aux.saveLocally(item, res, rej);
        } else if (item.type.location === 'server') {
          return aux.saveRemotely(item, res, rej);
        } else {
          return rej([true, "not support type"]);
        }
      });
    },
    load: function(type, key){
      var this$ = this;
      return new Promise(function(res, rej){
        if (aux.verifyType({
          type: type
        })) {
          return rej([true, "type incorrect"]);
        }
        if (type.location === 'local') {
          return aux.loadLocally(type, key, res, rej);
        } else if (type.location === 'server') {
          return aux.loadRemotely(type, key, res, rej);
        } else {
          return rej([true, "not support type"]);
        }
      });
    },
    list: function(type, filter){
      var this$ = this;
      filter == null && (filter = {});
      return new Promise(function(res, rej){
        if (aux.verifyType({
          type: type
        })) {
          return rej([true, "type incorrect"]);
        }
        if (type.location === 'local') {
          return aux.listLocally(type, res, rej);
        } else if (type.location === 'server') {
          return aux.listRemotely(type, res, rej);
        } else if (type.location === 'any') {
          return Promise.all([
            new Promise(function(res, rej){
              return aux.listLocally(type, res, rej);
            }), new Promise(function(res, rej){
              return aux.listRemotely(type, res, rej);
            })
          ]).then(function(ret){
            return res(ret[0].concat(ret[1]));
          });
        } else {
          return rej([true, "not support type"]);
        }
      });
    },
    'delete': function(type, key){
      var this$ = this;
      return new Promise(function(res, rej){
        if (!type || !key) {
          return rej([true, "param not sufficient"]);
        }
        if (type.location === 'local') {
          return aux.deleteLocally(type, key, res, rej);
        } else if (type.location === 'server') {
          return aux.deleteRemotely(type, key, res, rej);
        } else {
          return rej([true, "not support type"]);
        }
      });
    },
    backup: function(item){
      var this$ = this;
      return new Promise(function(res, rej){
        var path, count;
        path = "/db/backup/" + item.type.name + "/" + item.key;
        count = 0;
        localStorage.setItem(path + "/count", angular.toJson(count + 1));
        localStorage.setItem(path + "/" + count, angular.toJson(item));
        localStorage.setItem(path + "/" + count + "/timestamp", angular.toJson(new Date().getTime()));
        return res();
      });
    },
    backups: function(item){
      var this$ = this;
      return new Promise(function(res, rej){
        var path, count, ret, i$, idx, object, timestamp, e;
        path = "/db/backup/" + item.type.name + "/" + item.key;
        count = parseInt(localStorage.getItem(path + "/count") || 0);
        ret = [];
        for (i$ = 0; i$ < count; ++i$) {
          idx = i$;
          try {
            object = JSON.parse(localStorage.getItem(path + "/" + idx) || "");
            timestamp = JSON.parse(localStorage.getItem(path + "/" + idx + "/timestamp") || "0");
          } catch (e$) {
            e = e$;
            console.error("failed to parse backups for " + item.type.location + " / " + item.type.name + " / " + item.key);
            res([]);
          }
          ret.push({
            object: object,
            timestamp: timestamp
          });
        }
        return res(ret);
      });
    },
    cleanBackups: function(item){
      var this$ = this;
      return new Promise(function(res, rej){
        var path;
        path = "/db/backup/" + item.type.name + "/" + item.key;
        localStorage.setItem(path + "/count", "0");
        return res();
      });
    }
  };
}));
function in$(x, xs){
  var i = -1, l = xs.length >>> 0;
  while (++i < l) if (x === xs[i]) return true;
  return false;
}
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}