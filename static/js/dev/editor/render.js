// Generated by LiveScript 1.3.1
var plotdbDomain, sendMsg, store, dispatcher, x$, loadlib, properEval, saveLocal, snapshot;
plotdbDomain = plConfig.urlschema + "" + plConfig.domain;
sendMsg = function(msg){
  var e, i$, ref$, len$, item, k, ref1$, v;
  try {
    return window.parent.postMessage(msg, plotdbDomain);
  } catch (e$) {
    e = e$;
    if (msg.data) {
      for (i$ = 0, len$ = (ref$ = msg.data).length; i$ < len$; ++i$) {
        item = ref$[i$];
        if (item.data) {
          for (k in ref1$ = item.data) {
            v = ref1$[k];
            if (typeof v === 'function') {
              delete item.data[k];
            }
          }
        }
      }
      return window.parent.postMessage(msg, plotdbDomain);
    }
  }
};
store = {
  base: null,
  chart: null,
  module: null
};
window.addEventListener('click', function(){
  return sendMsg({
    type: 'click'
  });
});
window.addEventListener('keydown', function(e){
  var ref$;
  return sendMsg({
    type: 'keydown',
    event: (ref$ = {}, ref$.keyCode = e.keyCode, ref$.altKey = e.altKey, ref$.metaKey = e.metaKey, ref$.ctrlKey = e.ctrlKey, ref$.key = e.key, ref$.shiftKey = e.shiftKey, ref$.which = e.which, ref$)
  });
});
dispatcher = {
  handlers: {},
  register: function(name, handler){
    var ref$;
    return ((ref$ = this.handlers)[name] || (ref$[name] = [])).push(handler);
  },
  handle: function(evt){
    return (this.handlers[evt.data.type] || []).map(function(it){
      return it(evt.data);
    });
  },
  init: function(){
    var this$ = this;
    return window.addEventListener('message', function(e){
      return this$.handle(e);
    }, false);
  },
  fire: function(data){
    return this.handle({
      data: data
    });
  }
};
dispatcher.init();
x$ = dispatcher;
x$.register('config.set', function(payload){
  var ref$, config, rebind, chart;
  ref$ = {
    config: payload.config,
    rebind: payload.rebind
  }, config = ref$.config, rebind = ref$.rebind;
  if (!(chart = store.chart)) {
    return;
  }
  return chart.config(plotdb.chart.config.parse(config), chart.inited, rebind);
});
x$.register('init', function(payload){
  var ref$, base, library;
  ref$ = [JSON.parse(payload.chart), payload.library], base = ref$[0], library = ref$[1];
  return loadlib(library).then(function(){
    return properEval(base.code.content);
  }).then(function(){
    var ref$, chart, module;
    ref$ = (store.chart = new plotdb.view.chart(base), store), chart = ref$.chart, module = ref$.module;
    sendMsg({
      type: 'inited',
      config: JSON.stringify(plotdb.chart.config.preset(module.config)),
      dimension: JSON.stringify(module.dimension)
    });
    return dispatcher.fire({
      type: 'data.get(sample)'
    });
  });
});
x$.register('render', function(payload){
  var chart;
  if (!(chart = store.chart)) {
    return sendMsg({
      type: 'rendered'
    });
  }
  if (payload.data) {
    chart.data(payload.data, false);
  }
  if (payload.config) {
    chart.config(payload.config);
  }
  chart.attach('body > div:first-of-type', {});
  return sendMsg({
    type: 'rendered'
  });
});
x$.register('save', function(payload){
  return snapshot('png').then(function(payload){
    return sendMsg((payload.type = 'save', payload));
  });
});
x$.register('snapshot', function(payload){
  return snapshot(payload.format).then(function(payload){
    return sendMsg((payload.type = 'snapshot', payload));
  });
});
x$.register('data.update', function(payload){
  if (store.chart) {
    return store.chart.data(payload.data, true);
  }
});
x$.register('local.get', function(){
  return sendMsg({
    type: 'local.data',
    data: store.chart._.chart.local
  });
});
x$.register('data.get(sample)', function(){
  var chart, data;
  if (!(chart = store.module)) {
    return;
  }
  plotdb.chart.getSampleData(chart);
  data = plotdb.chart.fieldsFromDimension(chart.dimension);
  return sendMsg({
    type: 'data.sample',
    data: data
  });
});
loadlib = function(library){
  var load, promise, lib, url;
  library == null && (library = {});
  load = function(lib, url){
    return new Promise(function(res, rej){
      var x$, node;
      x$ = node = document.createElement('script');
      x$.type = 'text/javascript';
      x$.src = url;
      x$.onload = function(){
        return res(lib);
      };
      return document.head.appendChild(node);
    });
  };
  return promise = Promise.each((function(){
    var ref$, results$ = [];
    for (lib in ref$ = library) {
      url = ref$[lib];
      results$.push({
        lib: lib,
        url: url
      });
    }
    return results$;
  }()), function(d){
    return load(d.lib, d.url);
  });
};
window.addEventListener('error', function(){
  var ref$, e, lineno, msg, reBloburl, ret, lines;
  ref$ = [e.error, e.lineno || 0], e = ref$[0], lineno = ref$[1];
  if (!e) {
    msg = "failed with unknown error";
  } else if (typeof e !== typeof {}) {
    msg = e + "";
  } else if (!e.stack) {
    msg = e.toString();
  } else {
    msg = e.stack;
  }
  reBloburl = /blob:http%3A\/\/[^:]+:/;
  if (reBloburl.exec(msg)) {
    msg = msg.split(reBloburl).join("line ");
  }
  if (!lineno) {
    ret = /line (\d+):\d+/.exec(msg);
    lineno = ret ? parseInt(ret[1]) : 0;
  }
  if (msg.length > 1024) {
    msg = msg.substring(0, 1024) + "...";
  }
  lines = msg.split('\n');
  if (lines.length > 4) {
    msg = lines.splice(0, 4).join('\n');
  }
  return sendMsg({
    type: 'error',
    data: {
      msg: msg,
      lineno: lineno
    }
  });
});
properEval = function(src){
  return new Promise(function(res, rej){
    var code, script;
    code = src.trim()[0] === '{'
      ? "(function() { store.module = " + src + ";})()"
      : "(function() { " + src + "; store.module = {}; })()";
    script = document.createElement("script");
    script.onload = function(){
      URL.revokeObjectURL(script.src);
      res(store.module);
      return document.body.removeChild(script);
    };
    script.src = (store.code || (store.code = {})).url = URL.createObjectURL(new Blob([code], {
      type: "text/javascript"
    }));
    return document.body.appendChild(script);
  });
};
saveLocal = function(chart, key){
  return function(cb){
    var req;
    req = new XMLHttpRequest();
    req.onload = function(){
      if (cb) {
        return cb();
      }
    };
    req.open('put', plotdbDomain + "/e/chart/" + key + "/local", true);
    req.setRequestHeader('Content-Type', "application/json;charset=UTF-8");
    return req.send(JSON.stringify(chart.local));
  };
};
snapshot = function(format){
  format == null && (format = 'snapshot');
  return new Promise(function(res, rej){
    var allsvg, list, i$, to$, i, g, box, svgnode, styles, idx, style, ref$, width, height, inlineStyle, rate, svg, rgbaPercentToValue, img, encoded, e;
    try {
      Array.from(document.querySelectorAll('body > div:first-of-type svg')).forEach(function(node){
        var ref$, width, height, x$;
        ref$ = node.getBoundingClientRect(), width = ref$.width, height = ref$.height;
        x$ = node;
        x$.setAttribute("xmlns", "http://www.w3.org/2000/svg");
        x$.setAttribute("xmlns:xlink", "http://www.w3.org/1999/xlink");
        x$.setAttribute("width", width);
        x$.setAttribute("height", height);
        return x$;
      });
      allsvg = document.querySelectorAll('body > div:first-of-type svg');
      if (allsvg.length > 1) {
        list = Array.from(allsvg).map(function(it){
          var box;
          box = it.getBoundingClientRect();
          return [it.cloneNode(true), (box.right - box.left) * (box.bottom - box.top), it];
        });
        list.sort(function(a, b){
          return b[1] - a[1];
        });
        for (i$ = 1, to$ = list.length; i$ < to$; ++i$) {
          i = i$;
          g = document.createElementNS("http://www.w3.org/2000/svg", "g");
          g.appendChild(list[i][0]);
          list[0][0].insertBefore(g, list[0][0].childNodes[0]);
          box = list[i][2].getBoundingClientRect();
          g.setAttribute("transform", "translate(" + box.left + "," + box.top + ")");
        }
        svgnode = list[0][0];
      } else {
        svgnode = document.querySelector('body > div:first-of-type svg').cloneNode(true);
      }
      styles = svgnode.querySelectorAll("style");
      for (i$ = 0, to$ = styles.length; i$ < to$; ++i$) {
        idx = i$;
        style = styles[idx];
        if (!style.generated) {
          continue;
        }
        svgnode.removeChild(style);
      }
      styles = document.querySelectorAll('html style');
      for (i$ = styles.length - 1; i$ >= 0; --i$) {
        idx = i$;
        style = styles[idx].cloneNode(true);
        style.generated = true;
        svgnode.insertBefore(style, svgnode.childNodes[0]);
      }
      ref$ = svgnode.getBoundingClientRect(), width = ref$.width, height = ref$.height;
      inlineStyle = svgnode.getAttribute('style');
      svgnode.setAttribute('style', inlineStyle + ";" + document.querySelector("body > div:first-of-type > div").getAttribute('style'));
      svgnode.setAttribute('xmlns', "http://www.w3.org/2000/svg");
      svgnode.setAttribute('xmlns:xlink', "http://www.w3.org/1999/xlink");
      ref$ = svgnode.getBoundingClientRect(), width = ref$.width, height = ref$.height;
      if (!width || !height) {
        width = +(svgnode.getAttribute("width") || 0) || +(svgnode.style.width || "").replace(/[^0-9]+$/, "");
        height = +(svgnode.getAttribute("height") || 0) || +(svgnode.style.height || "").replace(/[^0-9]+$/, "");
      }
      if (format === 'png-hd') {
        if (width > 1920 || height > 1920) {
          width = Math.round(width * 2.1);
          height = Math.round(height * 2.1);
        } else {
          rate = 4000 / ((height > width ? width : height) || 1);
          width = width * rate;
          height = height * rate;
        }
        svgnode.setAttribute("width", width);
        svgnode.setAttribute("height", height);
      }
      Array.from(svgnode.querySelectorAll('*')).forEach(function(it){
        if (it.style.opacity === 0 || it.getAttribute('opacity') === 0 || it.getAttribute('display') === 'none' || it.style.display === 'none') {
          return it.parentNode.removeChild(it);
        }
      });
      svg = svgnode.outerHTML;
      rgbaPercentToValue = function(text){
        var re, str, ret, des;
        re = new RegExp(["([a-zA-Z-]+)\\s*", "([=:]?)\\s*(['\"]?)\\s*", "rgba\\(\\s*([0-9.]+%?)\\s*,\\s*([0-9.]+%?)\\s*,\\s*([0-9.]+%?)\\s*,\\s*([0-9.]+)\\s*\\)\\s*\\3"].join(""));
        str = text + "";
        for (;;) {
          ret = re.exec(str);
          if (!ret) {
            break;
          }
          des = [ret[1], ret[2] === ':' ? ':#' : '="#', [ret[4], ret[5], ret[6]].map(fn$).join(''), ret[2] === ':' ? ';' : '" ', ret[1], '-opacity', ret[2] === ':' ? ':' : '="', ret[7], ret[2] === ':' ? '' : '"'].join("");
          text = text.replace(ret[0], des);
          str = str.substring(ret.index + ret[1].length);
        }
        return text;
        function fn$(it){
          var v;
          if (it[it.length - 1] === '%') {
            v = Math.round(it.substring(0, it.length - 1) * 2.55).toString(16);
          } else {
            v = Math.round(+it).toString(16);
          }
          if (v.length < 2) {
            return "0" + v;
          } else {
            return v;
          }
        }
      };
      svg = rgbaPercentToValue(svg);
      svgnode.setAttribute('style', inlineStyle);
      if (format === 'svg') {
        res({
          format: 'svg',
          data: svg
        });
      }
      img = new Image();
      img.onload = function(){
        var canvas, ref$;
        canvas = (ref$ = document.createElement("canvas"), ref$.width = width, ref$.height = height, ref$);
        canvas.getContext('2d').drawImage(img, 0, 0, width, height, 0, 0, width, height);
        return res({
          format: format,
          data: canvas.toDataURL()
        });
      };
      encoded = base64.encode(utf8.encode(svg));
      return img.src = "data:image/svg+xml;charset=utf-8;base64," + encoded;
    } catch (e$) {
      e = e$;
      console.log(e);
      return res({
        format: format,
        data: null
      });
    }
  });
};