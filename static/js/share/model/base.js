// Generated by LiveScript 1.3.1
var model, ref$;
model = (ref$ = function(config){
  var ref$, deffields, user, key, permission;
  this.config = config;
  this.name = (ref$ = this.config).name;
  this.range = ref$.range;
  deffields = config.defaultFields;
  if (deffields === true) {
    ref$ = [model.type.user, model.type.id, model.type.permission], user = ref$[0], key = ref$[1], permission = ref$[2];
  } else if (typeof deffields === 'object') {
    ref$ = {
      user: deffields.user,
      key: deffields.key,
      permission: deffields.permission
    }, user = ref$.user, key = ref$.key, permission = ref$.permission;
  }
  if (user) {
    ((ref$ = this.config).base || (ref$.base = {})).owner = {
      required: true,
      type: model.type.key({
        type: user
      })
    };
  }
  if (key) {
    ((ref$ = this.config).base || (ref$.base = {})).key = {
      required: false,
      type: key
    };
  }
  if (permission) {
    this.config.base.permission = {
      required: true,
      type: permission
    };
  }
  return this;
}, ref$.prototype = {
  _validate: function(k, v, obj){
    var ret, value;
    if (v.required && obj == null) {
      return [true, k, 'required'];
    }
    if (obj == null) {
      return [false];
    }
    if (v.type) {
      ret = v.type.lint(obj);
      if (!ret || ret[0]) {
        return [true, k, 'type', ret];
      }
    }
    if (v.max || v.min) {
      if (v.type && v.type.range) {
        ret = v.type.range({
          min: v.min,
          max: v.max
        }, obj);
        if (ret[0]) {
          ret[1] = k;
          return ret;
        }
      } else {
        value = obj.length != null ? obj.length : obj;
        if (v.max && value > v.max) {
          return [true, k, 'max'];
        }
        if (v.min && value < v.min) {
          return [true, k, 'min'];
        }
      }
    }
    return [false];
  },
  validate: function(obj){
    var that, ret, i$, ref$, k, v, len$, item;
    if (that = this.config.self) {
      ret = this._validate(null, that, obj);
      if (ret[0]) {
        return ret;
      }
    }
    for (i$ = 0, len$ = (ref$ = [[null, this.config.self, obj]].concat((fn$.call(this)))).length; i$ < len$; ++i$) {
      item = ref$[i$];
      if (item[1]) {
        ret = this._validate(item[0], item[1], item[2]);
        if (ret[0]) {
          return ret;
        }
      }
    }
    return [false];
    function fn$(){
      var ref$, ref1$, results$ = [];
      for (k in ref$ = (ref1$ = this.config).base || (ref1$.base = {})) {
        v = ref$[k];
        results$.push([k, v, obj[k]]);
      }
      return results$;
    }
  },
  lint: function(obj){
    var ret;
    ret = this.validate(obj);
    if (!ret || ret[0]) {
      return ret;
    }
    if (this.config.lint) {
      return this.config.lint(obj);
    }
    return [false, null, null];
  },
  clean: function(obj){
    var that, this$ = this;
    if (that = this.config.clean) {
      obj = that(obj);
    }
    if (this['interface']) {
      import$((obj.getType = function(){
        return this$;
      }, obj), this['interface']);
    }
    return obj;
  },
  create: function(){
    var obj, k, ref$, ref1$, v, that, ref2$;
    obj = {};
    for (k in ref$ = (ref1$ = this.config).base || (ref1$.base = {})) {
      v = ref$[k];
      if (v['default'] != null) {
        obj[k] = v['default'];
      } else if (that = ((ref1$ = (ref2$ = v.type || (v.type = {})).config || (ref2$.config = {})).self || (ref1$.self = {}))['default']) {
        obj[k] = that;
      }
    }
    obj = (that = this.config.create) ? that(obj) : obj;
    return this.clean(obj);
  }
}, ref$);
model.type = import$({}, {
  boolean: new model({
    name: 'boolean',
    lint: function(it){
      return [!(!it || typeof it === typeof true)];
    }
  }),
  string: new model({
    name: 'string',
    lint: function(it){
      return [!(typeof it === typeof "" || typeof it === typeof 1)];
    },
    range: function(arg$, value){
      var min, max, length;
      min = arg$.min, max = arg$.max;
      length = (value + "").length;
      if (length < min) {
        return [true, null, 'min'];
      }
      if (length > max) {
        return [true, null, 'max'];
      }
      return [false];
    }
  }),
  email: new model({
    name: 'email',
    lint: function(it){
      return [!(it && typeof it === typeof "" && /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]+/.exec(it))];
    }
  }),
  number: new model({
    name: 'number',
    lint: function(it){
      return [!(typeof it === typeof 0)];
    }
  }),
  date: new model({
    name: 'date',
    lint: function(it){
      if (typeof it === typeof "" && !isNaN(new Date(it)) && it.length < 50) {
        return [false];
      }
      return [isNaN(it)];
    }
  }),
  array: function(m){
    return new model({
      name: 'array',
      type: m,
      lint: function(obj){
        var ret, idx;
        if (typeof obj !== typeof [] || isNaN(parseInt(obj.length))) {
          return [true];
        }
        ret = (function(){
          var i$, to$, results$ = [];
          for (i$ = 0, to$ = obj.length; i$ < to$; ++i$) {
            idx = i$;
            results$.push([idx, m.type.lint(obj[idx])]);
          }
          return results$;
        }()).filter(function(it){
          return it[1][0];
        })[0];
        if (!ret) {
          return [false];
        }
        return [true, ret[0], ret[1]];
      }
    });
  },
  key: function(m){
    return new model({
      name: 'key',
      type: m,
      lint: function(obj){
        if (typeof obj === typeof {} || typeof obj === typeof "" || typeof obj === typeof 0) {
          return [false];
        }
        return [true, null, 'type'];
      }
    });
  },
  keys: function(m){
    return new model({
      name: 'keys',
      type: m,
      lint: function(obj){
        var ret, idx;
        if (typeof obj !== typeof [] || isNaN(parseInt(obj.length))) {
          return [true];
        }
        ret = (function(){
          var i$, to$, results$ = [];
          for (i$ = 0, to$ = obj.length; i$ < to$; ++i$) {
            idx = i$;
            results$.push([idx, obj[idx]]);
          }
          return results$;
        }()).filter(function(it){
          return !it[1];
        })[0];
        if (!ret) {
          return [false];
        }
        return [true, ret[0], ret[1]];
      }
    });
  },
  id: new model({
    name: 'id',
    lint: function(){
      return [false];
    }
  })
});
import$(model.type, {
  permission: new model({
    name: 'permission',
    switches: ['private', 'public', 'list', 'token'],
    permtype: ['read', 'fork', 'write', 'admin'],
    lint: function(it){
      var i$, ref$, len$, item;
      if (!it) {
        return [true, null, 'ISNULL'];
      }
      if (typeof it !== 'object') {
        return [true, null, 'NOTOBJ'];
      }
      if (!(it['switch'] != null) || !Array.isArray(it['switch'])) {
        return [true, null, 'switch'];
      }
      if (!(it.value != null) || !Array.isArray(it.value)) {
        return [true, null, 'value'];
      }
      for (i$ = 0, len$ = (ref$ = it['switch']).length; i$ < len$; ++i$) {
        item = ref$[i$];
        if (!in$(item, model.type.permission.config.switches)) {
          return [true, item['switch'], 'switch'];
        }
      }
      for (i$ = 0, len$ = (ref$ = it.value).length; i$ < len$; ++i$) {
        item = ref$[i$];
        if (typeof item !== 'object') {
          return [true, item, 'value'];
        }
        if (!in$(item['switch'], model.type.permission.config.switches)) {
          return [true, item['switch'], 'switch'];
        }
        if (!in$(item.perm, model.type.permission.config.permtype)) {
          return [true, item.perm, 'permtype'];
        }
      }
      return [false];
    }
  }),
  user: new model({
    name: 'user',
    base: {
      username: {
        required: true,
        type: model.type.email
      },
      password: {
        type: model.type.string
      },
      usepasswd: {
        type: model.type.boolean
      },
      displayname: {
        max: 30,
        min: 3,
        required: true,
        type: model.type.string
      },
      description: {
        max: 1000,
        type: model.type.string
      },
      createdtime: {
        type: model.type.date
      },
      public_email: {
        type: model.type.boolean
      },
      datasize: {
        type: model.type.number
      },
      avatar: {
        max: 300,
        type: model.type.string
      }
    }
  })
});
module.exports = model;
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}
function in$(x, xs){
  var i = -1, l = xs.length >>> 0;
  while (++i < l) if (x === xs[i]) return true;
  return false;
}