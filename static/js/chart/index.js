// Generated by LiveScript 1.3.1
var x$;
x$ = angular.module('plotDB');
x$.filter('tags', function(){
  return function(it){
    if (Array.isArray(it)) {
      return it;
    } else {
      return (it || "").split(',');
    }
  };
});
x$.filter('date', function(){
  return function(it){
    return new Date(it);
  };
});
x$.filter('length', function(){
  return function(it){
    var k;
    return (function(){
      var results$ = [];
      for (k in it) {
        results$.push(k);
      }
      return results$;
    }()).length;
  };
});
x$.service('chartService', ['$rootScope', '$http', 'sampleChart', 'IOService', 'baseService'].concat(function($rootScope, $http, sampleChart, IOService, baseService){
  var service, object, chartService;
  service = {
    sample: sampleChart,
    link: function(chart){
      return "/chart/?k=" + chart.type.location.charAt(0) + chart.key;
    },
    thumblink: function(chart){
      return this.sharelink(chart) + "/thumb";
    },
    sharelink: function(chart){
      return "http://localhost/v/chart/" + chart.key;
    }
  };
  object = function(){
    if (typeof this.tags === 'string') {
      return this.tags = this.tags.split(',');
    }
  };
  object.prototype = {
    name: 'untitled',
    desc: null,
    tags: [],
    theme: null,
    doc: {
      name: 'document',
      type: 'html',
      content: service.sample[0].doc.content
    },
    style: {
      name: 'stylesheet',
      type: 'css',
      content: service.sample[0].style.content
    },
    code: {
      name: 'code',
      type: 'javascript',
      content: service.sample[0].code.content
    },
    config: {},
    dimension: {},
    assets: [],
    thumbnail: null,
    isType: false,
    likes: 0,
    parent: null,
    like: function(v){
      var this$ = this;
      return new Promise(function(res, rej){
        var ref$;
        this$.likes = (ref$ = this$.likes + (v
          ? 1
          : -1)) > 0 ? ref$ : 0;
        return $http({
          url: "/d/chart/" + this$.key + "/like",
          method: 'PUT'
        }).success(function(){
          return res();
        }).error(function(d, status){
          var ref$;
          this$.likes = (ref$ = this$.likes - (v
            ? 1
            : -1)) > 0 ? ref$ : 0;
          return rej();
        });
      });
    },
    addFile: function(name, type, content){
      var file;
      content == null && (content = null);
      file = {
        name: name,
        type: type,
        content: content
      };
      this.assets.push(file);
      return file;
    },
    removeFile: function(file){
      var idx;
      idx = this.assets.indexOf(file);
      if (idx < 0) {
        return;
      }
      return this.assets.splice(idx, 1);
    },
    updateData: function(){
      var len, k, v, i$, i, ret, ref$, that, results$ = [];
      this.data = [];
      len = Math.max.apply(null, (function(){
        var ref$, results$ = [];
        for (k in ref$ = this.dimension) {
          v = ref$[k];
          results$.push(v);
        }
        return results$;
      }.call(this)).reduce(function(a, b){
        return a.concat(b.fields || []);
      }, []).filter(function(it){
        return it.data;
      }).map(function(it){
        return it.data.length;
      }).concat([0]));
      for (i$ = 0; i$ < len; ++i$) {
        i = i$;
        ret = {};
        for (k in ref$ = this.dimension) {
          v = ref$[k];
          if (v.multiple) {
            ret[k] = (v.fields || (v.fields = [])).length
              ? (v.fields || (v.fields = [])).map(fn$)
              : [];
            v.fieldName = (v.fields || (v.fields = [])).map(fn1$);
          } else {
            ret[k] = (that = (v.fields || (v.fields = []))[0]) ? (that.data || (that.data = []))[i] : null;
            v.fieldName = (that = (v.fields || (v.fields = []))[0]) ? that.name : null;
          }
          if (v.type.filter(fn2$).length) {
            if (Array.isArray(ret[k])) {
              ret[k] = ret[k].map(fn3$);
            } else {
              ret[k] = parseFloat(ret[k]);
            }
          }
        }
        results$.push(this.data.push(ret));
      }
      return results$;
      function fn$(it){
        return (it.data || (it.data = []))[i];
      }
      function fn1$(it){
        return it.name;
      }
      function fn2$(it){
        return it.name === 'Number';
      }
      function fn3$(it){
        return parseFloat(it);
      }
    }
  };
  chartService = baseService.derive('chart', service, object);
  return chartService;
}));
x$.controller('chartEditor', ['$scope', '$http', '$timeout', '$interval', 'dataService', 'chartService', 'paletteService', 'themeService', 'plNotify'].concat(function($scope, $http, $timeout, $interval, dataService, chartService, paletteService, themeService, plNotify){
  import$($scope, {
    theme: null,
    showsrc: true,
    vis: 'preview',
    lastvis: null,
    plotdomain: 'http://localhost/',
    error: {
      msg: null,
      lineno: 0
    },
    codemirror: {
      code: {
        lineWrapping: true,
        lineNumbers: true,
        viewportMargin: Infinity,
        mode: 'javascript'
      },
      style: {
        lineWrapping: true,
        lineNumbers: true,
        viewportMargin: Infinity,
        mode: 'css'
      },
      doc: {
        lineWrapping: true,
        lineNumbers: true,
        viewportMargin: Infinity,
        mode: 'xml'
      },
      objs: []
    },
    chart: new chartService.chart(),
    canvas: {
      node: document.getElementById('chart-renderer'),
      window: document.getElementById('chart-renderer').contentWindow
    }
  });
  import$($scope, {
    _save: function(nothumb){
      var key, ref$, refresh, this$ = this;
      nothumb == null && (nothumb = false);
      delete $scope.unsaved;
      if (this.chart.owner !== $scope.user.data.key) {
        key = this.chart.type.location === 'server' ? this.chart.key : null;
        ref$ = this.chart;
        ref$.key = null;
        ref$.owner = null;
        ref$.permission = chartService.chart.prototype.permission;
        if (key) {
          this.chart.parent = key;
        }
      }
      refresh = !this.chart.key ? true : false;
      return this.chart.save().then(function(ret){
        return $scope.$apply(function(){
          var link;
          if (nothumb) {
            plNotify.send('warning', "chart saved, but thumbnail failed to update");
          } else {
            plNotify.send('success', "chart saved");
          }
          link = chartService.link($scope.chart);
          if (refresh || !window.location.search) {
            window.location.href = link;
          }
          if ($scope.save.handle) {
            $timeout.cancel($scope.save.handle);
          }
          return $scope.save.handle = null;
        });
      })['catch'](function(err){
        return $scope.$apply(function(){
          plNotify.aux.error.io('save', 'chart', e);
          console.error("[save chart]", err);
          if ($scope.save.handle) {
            $timeout.cancel($scope.save.handle);
          }
          return $scope.save.handle = null;
        });
      });
    },
    save: function(){
      var this$ = this;
      if (!$scope.user.data || !$scope.user.data.key) {
        return $scope.auth.toggle(true);
      }
      if (this.save.handle) {
        return;
      }
      this.save.handle = $timeout(function(){
        this$.save.handle = null;
        return this$._save(true);
      }, 3000);
      return this.canvas.window.postMessage({
        type: 'snapshot'
      }, this.plotdomain);
    },
    clone: function(){
      var key, ref$;
      this.chart.name = this.chart.name + " - Copy";
      key = this.chart.type.location === 'server' ? this.chart.key : null;
      ref$ = this.chart;
      ref$.key = null;
      ref$.owner = null;
      ref$.parent = key;
      ref$.permission = chartService.chart.prototype.permission;
      return this.save();
    },
    load: function(type, key){
      var this$ = this;
      return chartService.load(type, key).then(function(ret){
        this$.chart = new chartService.chart(import$(this$.chart, ret));
        this$.backup.check();
        return $timeout(function(){
          var ref$;
          return ref$ = this$.unsaved, delete this$.unsaved, ref$;
        }, 3000);
      })['catch'](function(ret){
        console.error(ret);
        plNotify.send('error', "failed to load chart. please try reloading");
        if (ret[1] === 'forbidden') {
          return window.location.href = window.location.pathname;
        }
      });
    },
    'delete': function(){
      var this$ = this;
      if (!this.chart.key) {
        return;
      }
      this['delete'].handle = true;
      return this.chart['delete']().then(function(ret){
        plNotify.send('success', "chart deleted");
        this$.chart = new chartService.chart();
        setTimeout(function(){
          return window.location.href = "/chart/me.html";
        }, 1000);
        return this$['delete'].handle = false;
      })['catch'](function(err){
        plNotify.send('error', "failed to delete chart");
        return this$['delete'].handle = false;
      });
    },
    resetConfig: function(){
      var k, ref$, v, results$ = [];
      for (k in ref$ = this.chart.config) {
        v = ref$[k];
        results$.push(v.value = v['default']);
      }
      return results$;
    },
    migrate: function(){
      var cloned, this$ = this;
      if (!this.chart.key) {
        return;
      }
      cloned = this.chart.clone();
      cloned.type.location = this.chart.type.location === 'local' ? 'server' : 'local';
      return cloned.save().then(function(){
        return this$.chart['delete']().then(function(){
          $scope.chart = cloned;
          return window.location.href = chartService.link($scope.chart);
        });
      });
    },
    dimension: {
      bind: function(event, dimension, field){
        var this$ = this;
        field == null && (field = {});
        return field.update().then(function(){
          if (dimension.multiple) {
            (dimension.fields || (dimension.fields = [])).push(field);
          } else {
            dimension.fields = [field];
          }
          return $scope.render();
        })['catch'](function(err){
          plNotify.send('error', "failed to bind field. try again later.");
          return console.error("chart.ls / dimension field binding failed due to : ", err);
        });
      },
      unbind: function(event, dimension, field){
        var idx;
        field == null && (field = {});
        idx = dimension.fields.indexOf(field);
        if (idx < 0) {
          return;
        }
        dimension.fields.splice(idx, 1);
        return $scope.render();
      }
    },
    reset: function(){
      return this.render();
    },
    render: function(rebind){
      var k, ref$, v, payload;
      rebind == null && (rebind = true);
      this.chart.updateData();
      for (k in ref$ = this.chart) {
        v = ref$[k];
        if (typeof v !== 'function') {
          this.chart[k] = v;
        }
      }
      payload = JSON.parse(angular.toJson({
        theme: this.theme,
        chart: this.chart
      }));
      ref$ = $scope.render;
      ref$.payload = payload;
      ref$.rebind = rebind;
      if (!rebind) {
        return this.canvas.window.postMessage({
          type: 'render',
          payload: payload,
          rebind: rebind
        }, this.plotdomain);
      } else {
        return this.canvas.window.postMessage({
          type: 'reload'
        }, this.plotdomain);
      }
    },
    renderAsync: function(rebind){
      var this$ = this;
      rebind == null && (rebind = true);
      if (this.renderAsync.handler) {
        $timeout.cancel(this.renderAsync.handler);
      }
      return this.renderAsync.handler = $timeout(function(){
        this$.renderAsync.handler = null;
        return this$.render(rebind);
      }, 500);
    },
    countline: function(){
      var this$ = this;
      return ['code', 'style', 'doc'].map(function(it){
        this$.chart[it].lines = this$.chart[it].content.split('\n').length;
        return this$.chart[it].size = this$.chart[it].content.length;
      });
    },
    download: {
      prepare: function(){
        var this$ = this;
        return ['svg', 'png', 'plotdb'].map(function(n){
          return setTimeout(function(){
            return $scope.$apply(function(){
              return [this$[n].url = '', this$[n]()];
            });
          }, 300);
        });
      },
      svg: function(){
        return $scope.canvas.window.postMessage({
          type: 'getsvg'
        }, $scope.plotdomain);
      },
      png: function(){
        return $scope.canvas.window.postMessage({
          type: 'getpng'
        }, $scope.plotdomain);
      },
      plotdb: function(){
        var payload;
        payload = angular.toJson($scope.chart);
        this.plotdb.url = URL.createObjectURL(new Blob([payload], {
          type: 'application/json'
        }));
        return this.plotdb.size = payload.length;
      }
    },
    colorblind: {
      val: 'normal',
      vals: ['normal', 'protanopia', 'protanomaly', 'deuteranopia', 'deuteranomaly', 'tritanopia', 'tritanomaly', 'achromatopsia', 'achromatomaly'],
      set: function(it){
        if (!in$(it, this.vals)) {
          return;
        }
        this.val = it;
        return $scope.canvas.window.postMessage({
          type: 'colorblind-emu',
          payload: it
        }, $scope.plotdomain);
      }
    },
    applyTheme: function(){
      var k, ref$, v, preset;
      if (this.chart && this.theme) {
        for (k in ref$ = this.chart.config) {
          v = ref$[k];
          if (v._bytheme) {
            delete this.chart.config[k];
          }
        }
        for (k in ref$ = this.chart.config) {
          v = ref$[k];
          if (!this.chart.config[k].hint) {
            continue;
          }
          preset = this.theme.typedef[this.chart.config[k].type[0].name];
          if (!preset) {
            continue;
          }
          if (preset[this.chart.config[k].hint] != null) {
            this.chart.config[k].value = preset[this.chart.config[k].hint];
          }
        }
        for (k in ref$ = this.theme.config) {
          v = ref$[k];
          if (!this.chart.config[k]) {
            this.chart.config[k] = import$({
              _bytheme: true
            }, v);
          } else if (this.chart.config[k].type[0] !== v.type[0]) {
            continue;
          } else {
            this.chart.config[k].value = v['default'];
          }
        }
      }
      if (this.theme) {
        return this.paledit.fromTheme(this.theme);
      }
    }
  });
  import$($scope, {
    backup: {
      enabled: false,
      guard: false,
      init: function(){
        var this$ = this;
        $scope.$watch('chart', function(){
          $scope.unsaved = true;
          if (!this$.enabled) {
            return;
          }
          if (this$.handle) {
            $timeout.cancel(this$.handle);
          }
          return this$.handle = $timeout(function(){
            this$.handle = null;
            return $scope.chart.backup().then(function(){});
          }, 2000);
        }, true);
        $timeout(function(){
          this$.guard = true;
          return $scope.unsaved = false;
        }, 3000);
        return window.onbeforeunload = function(){
          if (!this$.guard || !$scope.unsaved) {
            return null;
          }
          return "You have unsaved changes. Still wanna leave?";
        };
      },
      recover: function(){
        var this$ = this;
        if (!this.last || !this.last.object) {
          return;
        }
        $scope.chart.recover(this.last.object);
        this.enabled = false;
        return $scope.chart.cleanBackups().then(function(){
          return $scope.$apply(function(){
            return this$.check();
          });
        });
      },
      check: function(){
        var this$ = this;
        return $scope.chart.backups().then(function(ret){
          return $scope.$apply(function(){
            this$.list = ret;
            this$.last = ret[0];
            return $timeout(function(){
              return this$.enabled = true;
            }, 4000);
          })['catch'](function(err){
            return console.error('fecth backup failed: #', err);
          });
        });
      }
    },
    themes: {
      list: themeService.sample,
      set: function(it){
        return $scope.theme = it;
      },
      init: function(){
        var this$ = this;
        return themeService.list().then(function(ret){
          return $scope.$apply(function(){
            return this$.list = ret;
          });
        });
      }
    },
    editor: {
      'class': "",
      focus: function(){
        var this$ = this;
        return setTimeout(function(){
          return $scope.codemirror.objs.map(function(cm){
            var ret, k, v, this$ = this;
            ret = (function(){
              var ref$, results$ = [];
              for (k in ref$ = $scope.codemirror) {
                v = ref$[k];
                results$.push([k, v]);
              }
              return results$;
            }()).filter(function(it){
              return it[1].mode === cm.options.mode;
            })[0];
            if (!ret || !$scope.vis.startsWith(ret[0])) {
              return;
            }
            setTimeout(function(){
              return cm.focus();
            }, 10);
            if (ret[1].refreshed) {
              return;
            }
            cm.refresh();
            ret[1].refreshed = true;
            return setTimeout(function(){
              cm.refresh();
              if ($scope.error.lineno) {
                return $("#code-editor-code .CodeMirror-code > div:nth-of-type(" + $scope.error.lineno + ")").addClass('error');
              }
            }, 0);
          });
        }, 0);
      },
      update: function(){
        return this['class'] = [this.fullscreen.toggled ? 'fullscreen' : "", this.vis !== 'preview' ? 'active' : "", this.color.modes[this.color.idx]].join(" ");
      },
      fullscreen: {
        toggle: function(){
          this.toggled = !this.toggled;
          $scope.editor.update();
          return $scope.editor.focus();
        },
        toggled: false
      },
      color: {
        modes: ['normal', 'dark'],
        idx: 0,
        toggle: function(){
          this.idx = (this.idx + 1) % this.modes.length;
          return $scope.editor.update();
        }
      }
    },
    settingPanel: {
      toggle: function(){
        return this.toggled = !this.toggled;
      },
      toggled: false
    },
    sharePanel: {
      social: {
        facebook: null
      },
      isForkable: function(){
        var perms, ref$, forkable;
        perms = (ref$ = $scope.chart.permission).value || (ref$.value = []);
        return forkable = !!perms.filter(function(it){
          return it.perm === 'fork' && it['switch'] === 'public';
        }).length;
      },
      init: function(){
        var this$ = this;
        return ['#chartedit-sharelink', '#chartedit-embedcode'].map(function(eventsrc){
          var clipboard;
          clipboard = new Clipboard(eventsrc);
          clipboard.on('success', function(){
            $(eventsrc).tooltip({
              title: 'copied',
              trigger: 'click'
            }).tooltip('show');
            return setTimeout(function(){
              return $(eventsrc).tooltip('hide');
            }, 1000);
          });
          clipboard.on('error', function(){
            $(eventsrc).tooltip({
              title: 'Press Ctrl+C to Copy',
              trigger: 'click'
            }).tooltip('show');
            return setTimeout(function(){
              return $(eventsrc).tooltip('hide');
            }, 1000);
          });
          $scope.$watch('sharePanel.link', function(it){
            var fbobj, k, v, pinobj, emailobj, linkedinobj, twitterobj;
            this$.embedcode = "<iframe src=\"" + it + "\"><iframe>";
            this$.thumblink = chartService.thumblink($scope.chart);
            fbobj = {
              app_id: '1546734828988373',
              display: 'popup',
              caption: $scope.chart.name,
              picture: this$.thumblink,
              link: this$.link,
              name: $scope.chart.name,
              redirect_uri: 'http://plotdb.com/',
              description: $scope.chart.desc || ""
            };
            this$.social.facebook = (["https://www.facebook.com/dialog/feed?"].concat((function(){
              var ref$, results$ = [];
              for (k in ref$ = fbobj) {
                v = ref$[k];
                results$.push(k + "=" + encodeURIComponent(v));
              }
              return results$;
            }()))).join('&');
            pinobj = {
              url: this$.link,
              media: this$.thumblink,
              description: $scope.chart.desc || ""
            };
            this$.social.pinterest = (["https://www.pinterest.com/pin/create/button/?"].concat((function(){
              var ref$, results$ = [];
              for (k in ref$ = pinobj) {
                v = ref$[k];
                results$.push(k + "=" + encodeURIComponent(v));
              }
              return results$;
            }()))).join('&');
            emailobj = {
              subject: "plotdb: " + $scope.chart.name,
              body: $scope.chart.desc + " : " + this$.link
            };
            this$.social.email = (["mailto:?"].concat((function(){
              var ref$, results$ = [];
              for (k in ref$ = emailobj) {
                v = ref$[k];
                results$.push(k + "=" + encodeURIComponent(v));
              }
              return results$;
            }()))).join('&');
            linkedinobj = {
              mini: true,
              url: this$.link,
              title: $scope.chart.name + " on PlotDB",
              summary: $scope.chart.desc,
              source: "plotdb.com"
            };
            this$.social.linkedin = (["http://www.linkedin.com/shareArticle?"].concat((function(){
              var ref$, results$ = [];
              for (k in ref$ = linkedinobj) {
                v = ref$[k];
                results$.push(k + "=" + encodeURIComponent(v));
              }
              return results$;
            }()))).join('&');
            twitterobj = {
              url: this$.link,
              text: $scope.chart.name + " - " + ($scope.chart.desc || ''),
              hashtags: "dataviz,chart,visualization",
              via: "plotdb"
            };
            return this$.social.twitter = (["http://twitter.com/intent/tweet?"].concat((function(){
              var ref$, results$ = [];
              for (k in ref$ = twitterobj) {
                v = ref$[k];
                results$.push(k + "=" + encodeURIComponent(v));
              }
              return results$;
            }()))).join('&');
          });
          $scope.$watch('sharePanel.forkable', function(it){
            var forkable;
            forkable = this$.isForkable();
            if (forkable !== this$.forkable && this$.forkable != null) {
              $scope.chart.permission.value = it
                ? [{
                  'switch': 'public',
                  perm: 'fork'
                }]
                : [];
              return this$.saveHint = true;
            }
          });
          return $scope.$watch('chart.permission.value', function(){
            var forkable;
            forkable = this$.isForkable();
            if (this$.forkable !== forkable && this$.forkable != null) {
              this$.saveHint = true;
            }
            return this$.forkable = forkable;
          }, true);
        });
      },
      saveHint: false,
      embedcode: "",
      link: "",
      toggle: function(){
        if (this.init) {
          this.init();
        }
        this.init = null;
        this.toggled = !this.toggled;
        return this.saveHint = false;
      },
      toggled: false,
      isPublic: function(){
        return in$("public", $scope.chart.permission['switch']);
      },
      setPrivate: function(){
        var ref$;
        ((ref$ = $scope.chart).permission || (ref$.permission = {}))['switch'] = ['private'];
        return this.saveHint = true;
      },
      setPublic: function(){
        var ref$;
        ((ref$ = $scope.chart).permission || (ref$.permission = {}))['switch'] = ['public'];
        return this.saveHint = true;
      }
    },
    coloredit: {
      config: function(v, idx){
        return {
          'class': 'no-palette',
          context: "context" + idx,
          exclusive: true,
          palette: [v.value]
        };
      }
    },
    paledit: {
      convert: function(it){
        return it.map(function(it){
          return {
            id: it.key || Math.random() + "",
            text: it.name,
            data: it.colors
          };
        });
      },
      ldcp: null,
      item: null,
      fromTheme: function(theme){
        var themepal, k, v;
        if (!theme || !theme.config || !theme.config.palette) {
          return this.list = this.list.filter(function(it){
            return it.text !== 'Theme';
          });
        }
        themepal = this.list.filter(function(it){
          return it.text === 'Theme';
        })[0];
        if (!themepal) {
          themepal = {
            text: 'Theme',
            id: '456',
            children: null
          };
          this.list = [themepal].concat(this.list);
        }
        themepal.children = this.convert((function(){
          var ref$, results$ = [];
          for (k in ref$ = theme.config.palette) {
            v = ref$[k];
            results$.push((v.name = k, v));
          }
          return results$;
        }()));
        $('#pal-select option').remove();
        $('#pal-select optgroup').remove();
        return $('#pal-select').select2({
          allowedMethods: ['updateResults'],
          templateResult: function(state){
            var color, c;
            if (!state.data) {
              return state.text;
            }
            color = (function(){
              var i$, ref$, len$, results$ = [];
              for (i$ = 0, len$ = (ref$ = state.data).length; i$ < len$; ++i$) {
                c = ref$[i$];
                results$.push("<div class='color' " + ("style='background:" + c.hex + ";width:" + 100 / state.data.length + "%'") + "></div>");
              }
              return results$;
            }()).join("");
            return $(("<div class='palette select'><div class='name'>" + state.text + "</div>") + ("<div class='palette-color'>" + color + "</div></div>"));
          },
          data: this.list
        });
      },
      init: function(){
        var x$, iconPalSelectConfig, this$ = this;
        this.ldcp = new ldColorPicker(null, {}, $('#palette-editor .editor .ldColorPicker')[0]);
        this.ldcp.on('change-palette', function(){
          return setTimeout(function(){
            return $scope.$apply(function(){
              return this$.update();
            });
          }, 0);
        });
        this.list = [{
          text: 'Default',
          id: 'default',
          children: this.convert(paletteService.sample)
        }];
        x$ = $('#pal-select');
        x$.select2(iconPalSelectConfig = {
          allowedMethods: ['updateResults'],
          templateResult: function(state){
            var color, c;
            if (!state.data) {
              return state.text;
            }
            color = (function(){
              var i$, ref$, len$, results$ = [];
              for (i$ = 0, len$ = (ref$ = state.data).length; i$ < len$; ++i$) {
                c = ref$[i$];
                results$.push("<div class='color' " + ("style='background:" + c.hex + ";width:" + 100 / state.data.length + "%'") + "></div>");
              }
              return results$;
            }()).join("");
            return $(("<div class='palette select'><div class='name'>" + state.text + "</div>") + ("<div class='palette-color'>" + color + "</div></div>"));
          },
          data: this.list
        });
        x$.on('select2:closing', function(e){
          var i$, ref$, len$, item, ret;
          for (i$ = 0, len$ = (ref$ = this$.list).length; i$ < len$; ++i$) {
            item = ref$[i$];
            ret = item.children.filter(fn$)[0];
            if (ret) {
              break;
            }
          }
          if (!ret) {
            return;
          }
          $scope.$apply(function(){
            return this$.item.value = JSON.parse(JSON.stringify({
              colors: ret.data
            }));
          });
          return this$.ldcp.setPalette(this$.item.value);
          function fn$(it){
            return it.id === $(e.target).val();
          }
        });
        return x$;
      },
      update: function(){
        var ref$, src, des, pairing, i$, to$, i, d, j$, to1$, j, s, len$, pair, unpair;
        if (this.item) {
          ref$ = [this.item.value, this.ldcp.getPalette(), []], src = ref$[0], des = ref$[1], pairing = ref$[2];
          for (i$ = 0, to$ = des.colors.length; i$ < to$; ++i$) {
            i = i$;
            d = des.colors[i];
            for (j$ = 0, to1$ = src.colors.length; j$ < to1$; ++j$) {
              j = j$;
              s = src.colors[j];
              if (s.hex !== d.hex) {
                continue;
              }
              pairing.push([s, d, Math.abs(i - j)]);
            }
          }
          pairing.sort(function(a, b){
            return a[2] - b[2];
          });
          for (i$ = 0, len$ = pairing.length; i$ < len$; ++i$) {
            pair = pairing[i$];
            if (pair[0].pair || pair[1].pair) {
              continue;
            }
            pair[0].pair = pair[1];
            pair[1].pair = pair[0];
          }
          unpair = [
            src.colors.filter(function(it){
              return !it.pair;
            }), des.colors.filter(function(it){
              return !it.pair;
            })
          ];
          for (i$ = 0, to$ = Math.min(unpair[0].length, unpair[1].length); i$ < to$; ++i$) {
            i = i$;
            unpair[1][i].pair = unpair[0][i];
          }
          src.colors = des.colors.map(function(it){
            var ref$;
            if (it.pair) {
              return ref$ = it.pair, ref$.hex = it.hex, ref$;
            } else {
              return it;
            }
          });
          return src.colors.forEach(function(it){
            var ref$;
            return ref$ = it.pair, delete it.pair, ref$;
          });
        }
      },
      toggled: false,
      toggle: function(){
        this.toggled = !this.toggled;
        if (!this.toggled) {
          return this.update();
        }
      },
      edit: function(item){
        this.item = item;
        this.ldcp.setPalette(item.value);
        return this.toggled = true;
      }
    },
    switchPanel: function(){
      var this$ = this;
      return setTimeout(function(){
        return $scope.$apply(function(){
          var temp;
          temp = this$.vis;
          if (this$.vis === 'preview' && (!this$.lastvis || this$.lastvis === 'preview')) {
            this$.vis = 'code';
          } else if (this$.vis === 'preview') {
            this$.vis = this$.lastvis;
          } else {
            this$.vis = 'preview';
          }
          this$.lastvis = temp;
          if (this$.vis === 'preview') {
            return $scope.codemirror.objs.forEach(function(it){
              return it.getInputField().blur();
            });
          } else {
            return $scope.codemirror.objs.forEach(function(it){
              return it.refresh();
            });
          }
        });
      }, 0);
    },
    hidHandler: function(){
      var this$ = this;
      $scope.codemirrored = function(editor){
        return $scope.codemirror.objs.push(editor);
      };
      return document.body.addEventListener('keydown', function(e){
        if ((e.metaKey || e.altKey) && (e.keyCode === 13 || e.which === 13)) {
          return $scope.$apply(function(){
            return this$.switchPanel();
          });
        }
      });
    },
    checkParam: function(){
      var ret, key, ref$, location;
      if (!window.location.search) {
        return;
      }
      if (window.location.search === '?demo') {
        $scope.chart.doc.content = chartService.sample[1].doc.content;
        $scope.chart.style.content = chartService.sample[1].style.content;
        $scope.chart.code.content = chartService.sample[1].code.content;
        return;
      }
      ret = /[?&]k=([sl])([^&#|?]+)/.exec(window.location.search);
      if (!ret) {
        return;
      }
      key = ret[2];
      ref$ = [ret[1] === 's' ? 'server' : 'local', ret[2]], location = ref$[0], key = ref$[1];
      return $scope.load({
        name: 'chart',
        location: location
      }, key);
    },
    assets: {
      measure: function(){
        return $scope.chart.assets.size = $scope.chart.assets.map(function(it){
          return it.content.length;
        }).reduce(function(a, b){
          return a + b;
        }, 0);
      },
      preview: function(file){
        var datauri, iframe;
        this.preview.toggled = true;
        datauri = ["data:", file.type, ";charset=utf-8;base64,", file.content].join("");
        iframe = document.createElement("iframe");
        $('#assets-preview .iframe')[0].innerHTML = "<iframe></iframe>";
        return $('#assets-preview .iframe iframe')[0].src = datauri;
      },
      read: function(fobj){
        var this$ = this;
        return new Promise(function(res, rej){
          var name, that, type, file, fr;
          name = (that = /([^/]+\.?[^/.]*)$/.exec(fobj.name)) ? that[1] : 'unnamed';
          type = 'unknown';
          file = $scope.chart.addFile(name, type, null);
          fr = new FileReader();
          fr.onload = function(){
            var result, idx, type, content, size;
            result = fr.result;
            idx = result.indexOf(';');
            type = result.substring(5, idx);
            content = result.substring(idx + 8);
            size = $scope.chart.assets.map(function(it){
              return (it.content || "").length;
            }).reduce(function(a, b){
              return a + b;
            }, 0) + content.length;
            if (size > 3000000) {
              $scope.$apply(function(){
                plNotify.alert("Assets size limit (3MB) exceeded. won't upload.");
                $scope.chart.removeFile(file);
              });
            }
            file.type = type;
            file.content = content;
            $scope.$applyAsync(function(){
              return file.type = type, file.content = content, file;
            });
            return res(file);
          };
          return fr.readAsDataURL(fobj);
        });
      },
      handle: function(files){
        var i$, len$, file, results$ = [];
        for (i$ = 0, len$ = files.length; i$ < len$; ++i$) {
          file = files[i$];
          results$.push(this.read(file));
        }
        return results$;
      },
      node: null,
      init: function(){
        var x$, this$ = this;
        x$ = this.node = $('#code-editor-assets input');
        x$.on('change', function(){
          return this$.handle(this$.node[0].files);
        });
        return x$;
      }
    },
    monitor: function(){
      var this$ = this;
      this.assets.init();
      this.$watch('vis', function(vis){
        return $scope.editor.focus();
      });
      this.$watch('chart.assets', function(){
        return this$.assets.measure();
      }, true);
      this.$watch('chart.doc.content', function(){
        return this$.countline();
      });
      this.$watch('chart.style.content', function(){
        return this$.countline();
      });
      this.$watch('chart.code.content', function(){
        return this$.countline();
      });
      this.$watch('chart.doc.content', function(){
        return this$.renderAsync();
      });
      this.$watch('chart.style.content', function(){
        return this$.renderAsync();
      });
      this.$watch('theme', function(theme){
        this$.renderAsync();
        return this$.chart.theme = theme ? theme.key : null;
      });
      this.$watch('chart.theme', function(key){
        return this$.theme = this$.themes.list.filter(function(it){
          return it.key === key;
        })[0];
      });
      this.$watch('chart.code.content', function(code){
        if (this$.communicate.parseHandler) {
          $timeout.cancel(this$.communicate.parseHandler);
        }
        return this$.communicate.parseHandler = $timeout(function(){
          this$.communicate.parseHandler = null;
          return this$.canvas.window.postMessage({
            type: 'parse',
            payload: code
          }, this$.plotdomain);
        }, 500);
      });
      this.$watch('theme.code.content', function(code){
        if (!this$.theme) {
          return;
        }
        if (this$.communicate.parseThemeHandler) {
          $timeout.cancel(this$.communicate.parseThemeHandler);
        }
        return this$.communicate.parseThemeHandler = $timeout(function(){
          this$.communicate.parseThemeHandler = null;
          return this$.canvas.window.postMessage({
            type: 'parse-theme',
            payload: code
          }, this$.plotdomain);
        }, 500);
      });
      this.$watch('chart.config', function(n, o){
        var ret, k, v;
        o == null && (o = {});
        ret = !!(function(){
          var ref$, results$ = [];
          for (k in ref$ = n) {
            v = ref$[k];
            results$.push([k, v]);
          }
          return results$;
        }()).filter(function(arg$){
          var k, v;
          k = arg$[0], v = arg$[1];
          return !o[k] || v.value !== o[k].value;
        }).map(function(){
          return v.rebindOnChange;
        }).filter(function(it){
          return it;
        }).length;
        return this$.renderAsync(ret);
      }, true);
      this.$watch('chart.key', function(){
        return this$.sharePanel.link = chartService.sharelink(this$.chart);
      });
      $scope.limitscroll($('#data-fields')[0]);
      return $scope.limitscroll($('#chart-configs')[0]);
    },
    communicate: function(){
      var this$ = this;
      return window.addEventListener('message', function(arg$){
        var data;
        data = arg$.data;
        return $scope.$apply(function(){
          var ref$, config, dimension, k, v, typedef, payload, rebind, event, bytes, mime, buf, ints, i$, to$, idx;
          if (!data || typeof data !== 'object') {
            return;
          }
          if (data.type === 'error') {
            $('#code-editor-code .CodeMirror-code > .error').removeClass('error');
            $scope.error.msg = (data.payload || (data.payload = {})).msg || "";
            $scope.error.lineno = (data.payload || (data.payload = {})).lineno || 0;
            if ($scope.error.lineno) {
              return $("#code-editor-code .CodeMirror-code > div:nth-of-type(" + $scope.error.lineno + ")").addClass('error');
            }
          } else if (data.type === 'alt-enter') {
            return $scope.switchPanel();
          } else if (data.type === 'snapshot') {
            if (data.payload) {
              this$.chart.thumbnail = data.payload;
            }
            return this$._save();
          } else if (data.type === 'parse') {
            ref$ = JSON.parse(data.payload), config = ref$.config, dimension = ref$.dimension;
            for (k in ref$ = this$.chart.dimension) {
              v = ref$[k];
              if (dimension[k] != null) {
                dimension[k].fields = v.fields;
              }
            }
            for (k in ref$ = this$.chart.config) {
              v = ref$[k];
              if (config[k] != null) {
                config[k].value = v.value;
              }
            }
            for (k in config) {
              v = config[k];
              if (!(v.value != null)) {
                v.value = v['default'];
              }
            }
            ref$ = this$.chart;
            ref$.config = config;
            ref$.dimension = dimension;
            return $scope.render();
          } else if (data.type === 'parse-theme') {
            ref$ = JSON.parse(data.payload), config = ref$.config, typedef = ref$.typedef;
            ref$ = this$.theme;
            ref$.config = config;
            ref$.typedef = typedef;
            this$.applyTheme();
            return $scope.render();
          } else if (data.type === 'loaded') {
            if ($scope.render.payload) {
              payload = $scope.render.payload;
              rebind = $scope.render.rebind;
              this$.canvas.window.postMessage({
                type: 'render',
                payload: payload,
                rebind: rebind
              }, this$.plotdomain);
              return $scope.render.payload = null;
            } else {
              this$.canvas.window.postMessage({
                type: 'parse',
                payload: this$.chart.code.content
              }, this$.plotdomain);
              if (this$.theme) {
                return this$.canvas.window.postMessage({
                  type: 'parse-theme',
                  payload: this$.theme.code.content
                }, this$.plotdomain);
              }
            }
          } else if (data.type === 'click') {
            if (document.dispatchEvent) {
              event = document.createEvent('MouseEvents');
              event.initEvent('click', true, true);
              event.synthetic = true;
              return document.dispatchEvent(event);
            } else {
              event = document.createEventObject();
              event.synthetic = true;
              return document.fireEvent("onclick", event);
            }
          } else if (data.type === 'getsvg') {
            if (!data.payload) {
              return $scope.download.svg.url = '#';
            }
            $scope.download.svg.url = URL.createObjectURL(new Blob([data.payload], {
              type: 'image/svg+xml'
            }));
            return $scope.download.svg.size = data.payload.length;
          } else if (data.type === 'getpng') {
            if (!data.payload) {
              return $scope.download.png.url = '#';
            }
            bytes = atob(data.payload.split(',')[1]);
            mime = data.payload.split(',')[0].split(':')[1].split(';')[0];
            if (mime !== 'image/png') {
              return $scope.download.png.url = '#';
            }
            buf = new ArrayBuffer(bytes.length);
            ints = new Uint8Array(buf);
            for (i$ = 0, to$ = bytes.length; i$ < to$; ++i$) {
              idx = i$;
              ints[idx] = bytes.charCodeAt(idx);
            }
            $scope.download.png.url = URL.createObjectURL(new Blob([buf], {
              type: 'image/png'
            }));
            return $scope.download.png.size = bytes.length;
          }
        });
      }, false);
    },
    fieldAgent: {
      init: function(){
        var this$ = this;
        return $('#field-agent').on('mousewheel', function(){
          return this$.setPosition();
        });
      },
      data: null,
      drag: {
        ging: false,
        start: function(){
          return this.ging = true;
        },
        end: function(){
          return this.ging = false;
        }
      },
      setPosition: function(){
        var box, box2, scroll;
        if (!this.node) {
          return;
        }
        box = this.node.getBoundingClientRect();
        box2 = this.node.parentNode.parentNode.getBoundingClientRect();
        scroll = {
          left: $('#data-fields').scrollLeft(),
          top: $('#data-fields').scrollTop()
        };
        return $('#field-agent').css({
          top: (box.top - box2.top + 55 - scroll.top) + "px",
          left: (box.left - box2.left - scroll.left) + "px",
          width: box.width + "px",
          height: box.height + "px"
        });
      },
      setProxy: function(e, data){
        var ref$, node, this$ = this;
        if (this.drag.ging) {
          return;
        }
        ref$ = [data, e.target], this.data = ref$[0], node = ref$[1];
        for (;;) {
          if (node.getAttribute("class").indexOf('data-field') >= 0) {
            break;
          }
          node = node.parentNode;
          if (node.nodeName.toLowerCase() === 'body') {
            return;
          }
        }
        return setTimeout(function(){
          this$.node = node;
          return this$.setPosition();
        }, 0);
      }
    },
    settings: {
      changed: function(node, field){
        var ref$, cval, nval;
        ref$ = [$scope.chart[field], $(node).val()], cval = ref$[0], nval = ref$[1];
        if (!Array.isArray(cval)) {
          return cval !== nval;
        }
        ref$ = [cval, nval].map(function(it){
          return (it || []).join(",");
        }), cval = ref$[0], nval = ref$[1];
        return cval !== nval;
      },
      bind: function(node, field, config){
        var this$ = this;
        config == null && (config = {});
        $(node).select2();
        $(node).select2(config).on('change', function(){
          if (this$.changed(node, field)) {
            return setTimeout(function(){
              return $scope.$apply(function(){
                return $scope.chart[field] = $(node).val();
              });
            }, 0);
          }
        });
        return $scope.$watch("chart." + field, function(vals){
          var html, i$, ref$, len$, val;
          html = "";
          if (config.tags) {
            for (i$ = 0, len$ = (ref$ = vals || []).length; i$ < len$; ++i$) {
              val = ref$[i$];
              html += $("<option></option>").val(val).text(val)[0].outerHTML;
            }
            $(node).html(html);
          }
          if (this$.changed(node, field)) {
            return $(node).val(vals).trigger('change');
          }
        });
      },
      init: function(){
        this.bind($('#chart-setting-type'), 'basetype');
        this.bind($('#chart-setting-encoding'), 'visualencoding');
        this.bind($('#chart-setting-category'), 'category');
        return this.bind($('#chart-setting-tags'), 'tags', {
          tags: true,
          tokenSeparators: [',']
        });
      }
    },
    init: function(){
      this.communicate();
      this.hidHandler();
      this.monitor();
      this.checkParam();
      this.paledit.init();
      this.backup.init();
      this.fieldAgent.init();
      this.themes.init();
      return this.settings.init();
    }
  });
  return $scope.init();
}));
x$.controller('mychart', ['$scope', '$http', 'dataService', 'chartService'].concat(function($scope, $http, dataService, chartService){
  return chartService.list().then(function(ret){
    return $scope.$apply(function(){
      $scope.charts = ret;
      return $scope.goto = function(chart){
        return window.location.href = chartService.link(chart);
      };
    });
  });
}));
x$.controller('chartList', ['$scope', '$http', 'IOService', 'dataService', 'chartService', 'plNotify'].concat(function($scope, $http, IOService, dataService, chartService, plNotify){
  $scope.q = {
    type: null,
    enc: null,
    cat: null,
    dim: null,
    order: 'Latest'
  };
  $scope.qmap = {
    type: ["Other", "Bar Chart", "Line Chart", "Pie Chart", "Area Chart", "Bubble Chart", "Radial Chart", "Calendar", "Treemap", "Choropleth", "Cartogram", "Heatmap", "Sankey", "Venn Diagram", "Word Cloud", "Timeline", "Mixed"],
    enc: ["Other", "Position", "Position ( Non-aligned )", "Length", "Direction", "Angle", "Area", "Volume", "Curvature", "Shade", "Saturation"],
    cat: ["Other", "Infographics", "Geographics", "Interactive", "Journalism", "Statistics"],
    dim: [0, 1, 2, 3, 4, 5, "> 5"]
  };
  $scope.$watch('q', function(){
    if (!$scope.fullcharts || !$scope.fullcharts.length) {
      $scope.fullcharts = $scope.charts;
    }
    return $scope.charts = $scope.fullcharts.filter(function(it){
      return (!$scope.q.type || it.basetype === $scope.q.type) && (!$scope.q.enc || in$($scope.q.enc, it.visualencoding || [])) && (!$scope.q.cat || in$($scope.q.cat, it.category || [])) && (!$scope.q.dim || it.dimlen === $scope.q.dim || ($scope.q.dim === 99 && it.dimlen.length > 5));
    });
  }, true);
  $scope.like = function(chart){
    var mylikes, ref$, ref1$, v;
    if (!chart) {
      return;
    }
    mylikes = (ref$ = (ref1$ = $scope.user.data).likes || (ref1$.likes = {})).chart || (ref$.chart = {});
    v = mylikes[chart.key] = !mylikes[chart.key];
    return chart.like(v)['catch'](function(){
      plNotify.error("Can't do favorite. try again later?");
      return mylikes[chart.key] = !v;
    });
  };
  $scope.charts = [];
  return Promise.all([
    new Promise(function(res, rej){
      return IOService.aux.listLocally({
        name: 'chart'
      }, res, rej);
    }), new Promise(function(res, rej){
      return IOService.aux.listRemotely({
        name: 'chart'
      }, res, rej, "q=all");
    })
  ]).then(function(ret){
    var this$ = this;
    return $scope.$apply(function(){
      var hit, i$, to$, i, d, width, results$ = [];
      $scope.charts = (ret[0].concat(ret[1])).map(function(it){
        return new chartService.chart(it);
      });
      hit = false;
      for (i$ = 0, to$ = $scope.charts.length; i$ < to$; ++i$) {
        i = i$;
        d = $scope.charts[i];
        width = 320;
        if (Math.random() > 0.6 && !hit) {
          width = Math.random() > 0.8 ? 960 : 640;
          hit = true;
        }
        if (i % 3 === 2) {
          if (!hit) {
            width = 640;
          }
          hit = false;
        }
        results$.push(d.width = width);
      }
      return results$;
    });
  });
}));
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}
function in$(x, xs){
  var i = -1, l = xs.length >>> 0;
  while (++i < l) if (x === xs[i]) return true;
  return false;
}